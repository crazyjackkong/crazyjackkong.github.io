<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>监督学习和无监督学习</title>
      <link href="/post/62c7e70.html"/>
      <content type="html"><![CDATA[<p><strong>是否有监督（supervised），就看输入数据是否有标签（label）。输入数据有标签，则为有监督学习，没标签则为无监督学习</strong><br><a id="more"></a><br>这里我参考网络资料将机器学习分为；有监督学习、无监督学习、半监督学习和强化学习四类。</p><h1 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h1><ol><li><p>分类（classification）：<br>输入的训练数据有特征（feature），有标签（label）。<br>所谓的学习，其本质就是<strong>找到特征和标签间的关系（mapping）</strong>。从而给定新的特征，得出器相应的分类结果即标签。</p></li><li><p>回归（regression）：<br>其数据集是给定一个函数和它的一些坐标点，然后通过回归分析的算法，来估计原函数的模型，<strong>求出一个最符合这些已知数据集的函数，从而预测未知输入的输出值</strong>。</p></li></ol><p>分类和回归的主要区别就是输出结果是离散的还是连续的。</p><h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h1><p>聚类：把相似的东西聚在一起，并不需要知道类别是什么<br><strong>训练数据是无标签的，训练目标是能对数据进行区分和界定</strong></p><h1 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h1><p>是监督学习与无监督学习相结合的一种学习方法。半监督学习使用大量的未标记数据，以及同时使用标记数据，来进行模式识别工作。</p><p>它主要考虑如何<strong>利用少量的标注样本和大量的未标注样本进行训练和分类</strong>的问题。主要分为半监督分类，半监督回归，半监督聚类和半监督降维算法。</p><h1 id="强化学习（reinforcement-learning）"><a href="#强化学习（reinforcement-learning）" class="headerlink" title="强化学习（reinforcement learning）"></a>强化学习（reinforcement learning）</h1><p>摘自：<a href="https://easyai.tech/ai-definition/reinforcement-learning/" target="_blank" rel="noopener">https://easyai.tech/ai-definition/reinforcement-learning/</a><br>强化学习算法的思路非常简单，以游戏为例，如果在游戏中采取某种策略可以取得较高的得分，那么就进一步「强化」这种策略，以期继续取得较好的结果。这种策略与日常生活中的各种「绩效奖励」非常类似。我们平时也常常用这样的策略来提高自己的游戏水平。</p><p>在 Flappy bird 这个游戏中，我们需要简单的点击操作来控制小鸟，躲过各种水管，飞的越远越好，因为飞的越远就能获得更高的积分奖励。</p><p>这就是一个典型的强化学习场景：</p><pre><code>机器有一个明确的小鸟角色——代理需要控制小鸟飞的更远——目标整个游戏过程中需要躲避各种水管——环境躲避水管的方法是让小鸟用力飞一下——行动飞的越远，就会获得越多的积分——奖励</code></pre><p>强化学习和监督学习、无监督学习 最大的不同就是不需要大量的“数据喂养”。而是<strong>通过自己不停的尝试来学会某些技能。</strong></p><pre><code>参考https://www.zhihu.com/question/23194489https://easyai.tech/ai-definition/如reinforcement-learning</code></pre>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机3级考试嵌入式系统开发技术知识点总结（转载）</title>
      <link href="/post/156f943e.html"/>
      <content type="html"><![CDATA[<p>转自<a href="javascript:void(0" target="_blank" rel="noopener">嵌入式ARM</a>;) <em>1月23日</em></p><p>仅供个人查阅</p><p><strong>嵌入式系统</strong><br>嵌入式系统上的软件具有结构精简，<strong>代码轻量化，占用存储资源少</strong>的特点。</p><a id="more"></a><p>嵌入式系统和计算机操作系统的共同特征是：<strong>引导加载程序、外设驱动程序、操作系统、文件系统、网络协议栈、图形用户界面、数据库。</strong><br>嵌入式系统应用开发工具的主要目的：<strong>提高开发质量，缩短开发周期，降低开发成本。</strong><br>按照软硬件技术的<strong>复杂程度</strong>进行分类，可以把嵌入式系统分为：<strong>高端系统、终端系统和低端系统</strong>三大类。</p><p>仿真平台指嵌入式系统开发中使用的<strong>虚拟机管理软件、仿真软件或者指令集模式器</strong></p><p>对应内存容量而言1KB = 1024B，对应外存（磁盘、U盘）等容量而言，1KB=1000B</p><p>OS装载方式：串口、以太网和USB装载。</p><p>嵌入式应用程序经过交叉工具链生成映像文件后，需要下载到目标机进行调试。</p><p>调试完毕后映像文件必须有专用工具烧写到ROM中去，这种烧写工具俗称编程器！<br>文本根据排版格式可分为：纯文本和丰富文本。windows环境下，txt就是纯文本。相对于线性文本，超文本按着网状结构组织信息。WWW网页是最为常见超文本。</p><p>当前速度最快的CPU已经超过10GHz。</p><p><strong>嵌套向量中断控制器缩写为NVIC</strong></p><p>GCC是GNU套件的编译链接器，能编译C语言，汇编语言。</p><p>GDB调试下，file命令是装入需要<strong>调试的可执行文件</strong>，run命令<strong>执行当前被调试的程序</strong>。</p><p>源文件到可执行文件的步骤：<strong>预处理-&gt;编译-&gt;汇编-&gt;连接</strong>。<br>前向通道和后向通道<br>前向通道 - 输入接口，A/D<br>后向通道 - 输出接口，D/A</p><p>AX88796芯片内部寄存器的地址范围：0x10000000 ~ 0x100003FF<br><strong>嵌入式系统硬件的逻辑组成</strong><br>硬件主体中央处理器和存储器，他们通过IO接口或者IO设备与外部世界联系，并借助总线相互连接</p><p>中央处理器主要由运算器、控制器、寄存器和高速缓冲区（cache）组成<br><strong>嵌入式系统的特点</strong></p><ul><li><p>专用型</p></li><li><p>隐蔽型</p></li><li><p>资源受限</p></li><li><p>高可靠性</p></li><li><p>软件固化</p></li><li><p>实时性</p></li></ul><p><strong>嵌入式系统的CPU特点</strong></p><ul><li>实时处理</li><li>低功耗</li><li>结构特拓展性</li><li>集成了测试电路</li><li>4、8、16、32位字长</li></ul><p><strong>CPU</strong><br>嵌入式系统的CPU主要使用的有DSP、RAM以及FPGA。</p><p>DSP介绍</p><ul><li>适用于数字信号处理的微处理器（DSP并非高性能通用处理器，它是一种专用于数字信号处理的微处理器） </li><li>支持单指令多数据（SIMD）并行处理的指令</li><li>显著提高音频、视频等数字信号的数据处理效率</li><li>手机和数码产品均有DSP</li></ul><p><strong>嵌入式开发流程</strong><br>需求分析和规格说明 -&gt; 系统设计 -&gt; 构件设计 -&gt; 系统集成与测试</p><p>测试的目的是验证模块/系统的功能和性能，以及时发现错误</p><p>基于嵌入式WEB的应用系统中，构件设计阶段需要设计支持以太网通信的电路，包括以太网控制电路和以太网驱动电路。AX8879芯片内部寄存器的读/写地址，其首地址一般是0x1000 0000 </p><p><strong>嵌入式开发特点</strong></p><ul><li>宿主机 - 目标机的开发架构</li><li>与底层硬件控制程序的关系密切</li><li>软硬件资源受限制</li><li>需要固化程序</li></ul><p><strong>嵌入式系统开发调试工具</strong></p><ul><li>在线仿真器</li><li>JTAG适配器</li><li>示波器</li></ul><p>GPIO</p><p>GPIO引脚一般是多功能复用的，具有0态，1态和高阻态。</p><p>作为输入接口时一般具有缓冲功能，作为输出接口时一般具有锁存功能。</p><p>GPIO可以实现并行IO，SPI、UART、I2C都是串行。<br><strong>UART</strong></p><p>UART由发生器、接收器、控制单元以及<strong>波特率发生器</strong>等组成。</p><p>可实现全双工通信!</p><p>RAM芯片中的UART收发信息时，可以采用FIFO，也可以采用普通模式</p><p>一般接收和发送缓冲区的FIFO字节数一样的，<strong>长度</strong>可编程选择4B、8B、16B、64B。</p><p>UART传送消息的格式是以起始位开始以停止位结束</p><p>UART传送信息时，一次可传输的数据位可以是<strong>5，6，7，8位</strong>，由编程决定</p><p>基于UART可组成RS-232接口</p><p>RS232 - 最远15m</p><p>RS485 - 最远1.2k<br>RAM实现485总线的功能，需要采用S3C2410芯片内部的UART部件外加转换芯片等来实现。在软件设计时，初始化波特率9600bps，数据格式格式为：8位数据位，无数据检验位，1位停止位。那么1s时间内最多传输960个字节。<strong>（**</strong>注意计算还得加上起始位和停止位）<strong></strong>CAN**</p><ul><li>即： 控制器局域网</li><li>能够实现多主通信</li><li>CAN总线的数据帧由7个不同的域组成，其中域的长度可以是0~8位</li><li>采用CRC校验</li><li>RAM芯片内部嵌入CAN控制器</li></ul><p><strong>键盘</strong><br>8个GPIO脚最多构成64个按键的键盘<br>矩阵键盘通常有行扫描法和反转法读取按键的特征值（还有一种方法叫做中断方式）<br><strong>嵌入式处理器内核的分类</strong><br>按照字长可以分为：8/16/32/64 位结构</p><p>按照存储可以分为：冯诺依曼和哈佛(程序和数据分开存储)结构</p><p>按照指令集可以分为：CISC、 RISC结构</p><p>CISC(complex instruction set computer 复杂指令集)</p><p>RISC(reduced instruction set computer 精简指令集)<br><strong>SOC片上系统</strong><br>SOC已成为嵌入式处理器芯片的主流发展趋势</p><p>它是集成电路进入<strong>深亚微米时代</strong>的产物</p><p>既能把数字电路也能把模拟电路集成到单个芯片上</p><p>包含数字电路、模拟电路以及射频电路</p><p>单个芯片即可完成采集、转换、存储、处理和I/O等多种功能</p><p>SOC有通用SOC芯片和专用SOC芯片之分</p><p>专用SOC芯片按其工艺分为定制芯片和现场可编程芯片两类<br><strong>集成电路</strong><br>集成电路有小规模(SSI)、中规模(MSI)、大规模(LSI)、超大规模(VLSI)和极大规模(ULSI)组成，<strong>嵌入式处理芯片一般属于VLSI和USLI</strong>。</p><p>集成电路大多是在硅衬底上制作，硅衬底是单晶硅锭经切割，研磨和抛光而成的圆形薄片。</p><p>集成电路中的电路及电子元件，需要反复交叉氧化、光刻、掺杂和互连等工序才能制成。<br><strong>嵌入式最小系统组成</strong><br>嵌入式系统一般包括嵌入式处理器、时钟电路、电源电路、复位电路、存储器和调试测试接口。<br><strong>JTAG调试技术</strong><br>JTAG标准中规定的TAP接口具有5根信号线<br>构建一个宿主机 - 目标机的开发环境，若目标机是裸机，那么为了调试和下载软件需要将调试仿真器连接到目标机的JTAG接口！</p><p>JATG是一种嵌入式测试技术，大多数嵌入式CPU、DSP、FPGA器件都支持JTAG</p><p>JTAG允许多个芯片的边界扫描寄存器BSR通过JTAG接口串联在一起，实现对多个器件的测试</p><p>通过JTAG可以实现在线编程功能<br><strong>主频时钟</strong><br>0.01s基准定时时间选用S3C2410芯片内部的Timer0部件产生。若系统的主频参数PCLK=264MHz，分频器选择16，预分频系数选择为3，那么，Timer0的计数常数为：41250</p><p>计算方法：<strong>定时器输入时钟频率 = PCLK/(预分频系数+1)/（分割器值），计数常数 = 定时间间隔/（1/定时器输入时钟频率）</strong></p><p>带宽 = 总线频率 × 数据线宽度 / 8 × 次数 / 周期<br><strong>板级升级包（BSP）</strong><br>引导加载程序、初始化程序、设备驱动程序、配置文件</p><p>含有电路板的初始化程序</p><p>所有与特定电路板上硬件相关的功能都集成在板级支持包的库里</p><p>操作系统的上层代码通过板级支持包访问底层硬件<br><strong>ARM</strong><br><strong>单指令周期</strong>和<strong>流水线技术</strong>是RAM处理器的技术特征。</p><p>RAM都是RISC，但是存储结构有的是哈佛结构，有的是冯诺依曼结构。</p><p><strong>PowerPC、MC68K、MIPS都是RISC，哈佛结构！</strong></p><p>Cortex 系列分为A-R-M ，A系列是面向尖端虚拟内存的操作系统和用户应用，R系列是针对实时系统，M系列是对微控制器。 Cortex - M3系列是哈佛结构。</p><p>RAM内部一般有：UART/I2C/SPI/CAN/USB/Ethernet等多个互连通信组件</p><p>RAM处理器共37个，包括31个通用寄存器（含PC）和6个状态寄存器</p><p><strong>RAM异常</strong></p><p>将CPRS的值保存到将要执行的异常中断对应的SPSR中</p><p>设置CPSR的相应位</p><p>断点地址保存到R14</p><p>PC赋值，转入向量地址<br><strong>ADS</strong><br>按照存储区域类型划分为3类，RO段，RW段，ZI段，RO段是指代码存储区和常数存储区，具有只读属性</p><p>可执行输出文件有3个生成目标：Debug、Release、DEbugRel</p><p>工程项目按照一定的逻辑来分组管理文件：</p><p>文件映射关系较简单时：使用编译、链接选项来确定输入文件的连接关系</p><p>地址映射关系较复杂时：使用scatter（分散加载）格式的文件来确定输入文件的连接关系<br><strong>RVDS</strong><br>RVDS开发工具套件中，主要包括工程管理器、编译连接器、调试器和指令集仿真器。调试器支持硬件<strong>在线调试和软件仿真调试</strong>。<br><strong>电源管理模块</strong></p><ul><li>正常模式</li><li>慢速模式</li><li>休眠模式 - 仅断开RAM内核时钟FCLK，CPU处于休眠模式，仍为外围硬件组件提供时钟。</li><li>掉电模式 - 切断内部电源，除非唤醒逻辑有效，否则内核不产生功耗</li></ul><p>正常模式下，电源管理模式为内核及RAM芯片内部所有硬件组成提供时钟源，用户可以通过软件控制暂时不用的内置硬件组件处于关闭状态降低功耗。<br><strong>硬件抽象层HAL</strong><br>向操作系统内核提供了访问硬件底层的函数接口</p><p>嵌入式软件中直接访问底层硬件的例程集合</p><p>增加的HAL位于硬件电路板和操作系统内核之间</p><p>嵌入式电路板的最基本软件</p><p>HAL函数是移植操作系统的基础</p><p>HAL<strong>隐藏了不同硬件平台的差异性</strong>，从而改善了操作系统的可移植性！<br><strong>AMBA总线</strong><br>RAM的总线结构成为 AMBA -先进微控制器总线结构（一种开放式总线结构）</p><p>从1995的AMBA1.0到目前的AMBA4.0共四个版本！</p><p>RAM7 - AMBA1; RAM11 - AMBA2</p><p>按照AMBA总线规范，基于RAM内核的嵌入式处理芯片采用<strong>系统总线</strong>和<strong>外围总线</strong>两层结构的方式构建片上系统</p><p>连接系统总线的高带宽组件（<strong>AHB接口</strong>）主要包括：电源管理和时钟控制器，<strong>测试接口</strong>（<strong>JTAG</strong>），外部存储器控制接口，DMA控制器，USB主机，中断控制器。（可以看出大多数为控制器）</p><p><strong>RTC是与外围总线（APB接口）连接的硬件组件</strong></p><p><strong>MMU</strong><br>MMU，<strong>内存管理单元，</strong>它是用来<strong>管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址</strong>，以及提供硬件机制的内存访问授权。</p><p>虚拟地址到物理地址的转换通过查找页表来完成，每次在访问内存时先插TLB，查不到再到内存中查整个页表。<br><strong>ARM7 ≠ ARMv7</strong><br>RAM7 - 冯诺依曼的结构。 <strong>RAM9~RAM11</strong> 采用哈佛结构！<br><strong>ARMv7</strong>是一种构架。ARM7是一种处理器型号，<strong>ARM7</strong>（冯诺依曼结构）是在ARMv4构架上设计出来的处理器。<strong>RAM11（ARMv6架构）</strong>之后便是以<strong>Cortex（ARMv7架构）</strong>来命名了！<br><strong>ARM7没有MMU(内存管理单元)</strong>，只能叫做MCU（微控制器），不能运行诸如<strong>Linux、WinCE（大型嵌入式操作系统）</strong>等这些现代的<strong>多用户多进程操作系统</strong>，因为运行这些系统需要MMU，才能给每个用户进程分配进程自己独立的地址空间。ucOS、ucLinux这些精简实时的<strong>RTOS不需要MMU，当然可以在ARM7上运行</strong>。</p><p>ARM9、ARM11，是嵌入式CPU（处理器），带有MMU，可以运行诸如Linux等多用户多进程的操作系统，应用场合也不同于ARM7。</p><p>此外，Cortex-M系列还细分为M0、M3、M4和超低功耗的M0+，用户依据成本、性能、功耗等因素来选择芯片。</p><p><strong>Cortex-M系列（ARMv7架构）的指令集只有Thumb-2。</strong></p><p><strong>ARM处理器 ≠ ARM处理器核</strong></p><ul><li><p>处理器核：在某种架构的基础上具有取指令和执行指令的组件。</p></li><li><p>处理器： 以处理器核为中心，加上MMU，中断控制器，浮点运算器，总线接口等就构成了RAM处理器。</p></li><li><p>当然了，单独的处理器核也可以作为某一代RAM处理器的。</p></li></ul><p><strong>RAM常考寄存器</strong></p><ul><li>R13 - SP （堆栈指针）</li><li>R14 - LR（链接寄存器）</li><li>R15 - PC（程序计数器）</li><li><strong>xPSR - （CPSR 和 SPSR）状态寄存器</strong></li></ul><p><strong>SP寄存器</strong></p><p>SP有两个，分别为R13(MSP)和R13(PSP)即主堆栈指针（MSP）和进程堆栈指针（PSP），但在同一时刻只能有一个可以看到，这也就是所谓的“banked”寄存器。</p><p>这些寄存器都是32位的。<br><strong>CPSR寄存器</strong><br>CPSR(当前程序状态寄存器)在任何处理器模式下被访问。它包含了<strong>条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。</strong></p><p>RAM中表示程序状态的寄存器是CPSR，其中状态位T的作用是在RAM状态与Thumb状态间进行切换，当T = 1时处理器处于的状态是Thumb状态。</p><p>N为符号标志位 - N=1表示运算结果为负，否则运算结果为正</p><p>F为禁止快读中断为 - F=1表示禁止快速中断控制位，否则允许！</p><p>V为溢出标志位，等于1表示溢出</p><p>Z为全0标志，运算结果为0</p><p><strong>SPSR寄存器</strong><br>每一种处理器模式下（看下面的其中运行模式）都有一个专用的物理状态寄存器，称为SPSR（备份程序状态寄存器）。</p><p>当特定的<strong>异常中断</strong>发生时，这个寄存器用于存放<strong>当前程序状态寄存器</strong>的内容。在异常中断退出时，可以用<strong>SPSR来恢复CPSR</strong>。</p><p>由于用户模式和系统模式不是异常中断模式，所以他没有SPSR。当用户在用户模式或系统模式访问SPSR，将产生不可预知的后果。<br><strong>控制寄存器和数据寄存器</strong><br>控制寄存器是4个字节，比如端口E的控制寄存器rGPECON = 0x00005555</p><p>数据寄存器是2个字节，比如端口E的数据寄存器rGPEDAT=0x0020<br>关于赋值，也写一个小例子<br><em>rGPDCON = ((rGPDCON | 0x00005555) &amp; 0xFFFF5555);//GPD0~GPD7配置为输出模式</em><br>先置位，然后再清零。<br><strong>ARM微处理器的七种运行模式</strong></p><ul><li>用户模式：user （没有SPSR寄存器）：正常程序执行的模式</li><li>系统模式 – SYS （没有SPSR寄存器）： 用于运行特权级的操作系统任务</li><li>快速中断模式 – FIQ ：用于高速数据传输和通道处理、高速中断！</li><li>外部中断模式 – IRQ ：用于通常的中断处理</li><li>管理模式 – SVC ：又称特权模式，操作系统使用的一种保护模式</li><li>终止模式 – ABT ：用于虚拟存储及存储保护，处理存储器故障</li><li>未定义指令模式 – UND ：用于支持通过软件方针硬件的协处理器</li></ul><p><strong>经典RAM的七种异常</strong></p><ul><li>复位RESET</li><li>未定义指令 UND</li><li>软件中断 SWI</li><li>指令预取终止 PABT</li><li>数据访问终止 DABT</li><li>外部中断请求 IRQ</li><li>快速中断FIQ</li></ul><p><strong>IRQ</strong><br>IRQ异常对应的异常向量地址为：0x00000018<br>IRQ异常向量地址和下一个异常向量地址之间的间隔为4个字节<br>复位异常的异常向量地址是0x00000000。系统上电复位后，将从该地址处执行程序，RAM9的体系结构规定的各异常向量地址间隔通常是4个字节，以此复位异常向量地址处通常存储一条分支指令<br><strong>S3C2410必备知识</strong><br>S3C2410拥有2个串口，UART0/UART1</p><p>控制组件包括存储器控制器、总线控制器、外部主控器、NAND FLASH（以页为单位进行闪存）</p><p>存储器控制器提供访问外部存储器所需的存储器控制信号，支持大小端模式，地址空间供1GB，8个BANK，每个BANK128MB。</p><p>以ARM芯片为信合的嵌入式系统其I/O与存储器采用统一编址的方式，并不像×86那样采用I/O映射编址（独立编址）</p><p>只有BANK0是总线16、32位的访问，其他BANK均可以进行8、16、32位的访问</p><p>GPIO 有GPIOA~H</p><p>哈佛体系结构，数据与程序存储分开</p><p>哈佛体系结构，数据与程序存储分开</p><p>内部集成ADC<br><strong>矩阵按键代码</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt; \#define KEYOUTPUT (*(VOLATILE int8u *)0X56000044)</span><br><span class="line">&gt; \#define KEYINPUT (*(VOLATILE int8u *)0X56000044)</span><br><span class="line">&gt; INT16U ScanKey()</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     INT16U key = 0xFFFF;</span><br><span class="line">&gt;     INT16U i;</span><br><span class="line">&gt;     INT8U temp=0xFF, output;</span><br><span class="line">&gt;     rGPECON = ((rGPECON &amp; 0xFFFFFF00) | 0x00000055); //初始化GPE0~GPE3为输出</span><br><span class="line">&gt;     rGPECON = rGPECON &amp; 0xFFFFFF0F; //初始化GPE4~GPE7为输入</span><br><span class="line">&gt;     //判断键盘中是否有键按下</span><br><span class="line">&gt;     for(i=1; ((i&lt;=8) &amp;&amp; (i&gt;0)); i&lt;&lt;=1)</span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;         output |= 0xFF;</span><br><span class="line">&gt;         output &amp;= (~i);</span><br><span class="line">&gt;         KEYOUTPUT = output;</span><br><span class="line">&gt;         temp = KEYINPUT;</span><br><span class="line">&gt;         if((temp &amp; 0xF0) != 0xF0)//判断列信号是否全部为1</span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             key = (~i);</span><br><span class="line">&gt;             key &lt;&lt;= 8;</span><br><span class="line">&gt;             key |= ((temp &amp; 0xF0)|0x0F);</span><br><span class="line">&gt;             return key;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     return 0xFFFF;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; //key返回判断哪个按键的方法：最高4位和最低四位都是1，</span><br><span class="line">&gt; //即 1111 ---- ---- 1111，然后次高字节是行，再次高是列，</span><br><span class="line">&gt; //比如第2行第3个按键按下, 对应为 1111 1101 1011 1111 - 0xFDBF</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>网络</strong><br>WLAN通信协议是<strong>802.11</strong></p><p>传输速率可达到<strong>11Mbps，54Mbps，108Mbps</strong>。<br><strong>IP</strong><br>IP地址分为A类、B类、C类三个基本类。另外两类分别为组播地址和备用地址。</p><p>IP地址解决了网络中所有计算机统一编址的问题</p><p>IP数据报是一种独立于各种物理网络的数据包格式</p><p>路由器是实现网络与网络互连的关键设备<br><strong>A类</strong></p><p>1.0.0.0 到126.255.255.255</p><p>分配给具有大量主机而局域网络数量较少的大型网络</p><p>由1个字节的网络地址和3个字节主机地址组成</p><p>网络地址的最高位必须是“0”，即第一字段的范围 0~127，但是由于全0和全1的地址用作特殊用途，实际可指派的第一个字段范围是1~126</p><p>每个IP地址可连16387064台主机，Internet有126个A类地址</p><p>可以用于多目的地址发送，言外之意可以组播<br><strong>B类</strong></p><p>128.0.0.0到191.255.255.255</p><p>用于国际性大公司和政府机构</p><p>前两个八位字节指明网络，后两个八位字节指明网络上的主机<br><strong>C类</strong><br>C类IP地址范围192.0.0.0 ~ 223.255.255.255</p><p>第1、2、3字节为网络地址，第四个字节为主机地址</p><p>C类地址数量较多，使用于局部局域网中，每个网络中最多包含254台计算机</p><p>用于一般小公司 校园网 研究机构<br><strong>以太网数据帧（里面不包括IP地址）</strong><br>前导码（7个字节） -&gt; 帧起始界定符(1字节) -&gt; 目的MAC地址(6字节) -&gt; 源MAC地址（6字节）-&gt; 类型/长度（2字节） -&gt; 数据(46~1500字节) -&gt;帧校验序列(4字节)</p><p>局域网采用分组交换技术</p><p>发送设备MAC地址 - &gt; 接收设备MAC地址 -&gt; 控制信息 -&gt;有效载荷 -&gt; 校验信息<br><strong>路由器</strong><br>多个异构或者同构网络进行互联</p><p>网络层</p><p>集线器来放大信号实现远距离传输</p><p>协议转换器：用于传输层及以上各层的协议转换</p><p>热点 - 正式名称无线接入点，它实际上是一个无线交换机或无线路由器。<br><strong>局域网</strong><br>按照介质所使用的访问控制方法可分为：以太网，FDDI网和令牌网</p><p>必不可少的部分是集线器与交换机<br><strong>指令集</strong><br>Thumb指令集是16位的，ARM指令集是32位的，中间有Thumb-2作为桥接。<br><strong>ARM处理器的三种工作状态</strong></p><ul><li>ARM状态 (指令宽度32)</li><li>Thumb 及 Thumb-2状态</li><li>调试状态</li></ul><p><strong>Thumb状态和ARM状态的切换</strong></p><ul><li>通过BX指令，写数据到操作数寄存器（R0）的最低位。</li><li>R0[0]=1 – 从RAM状态切换到Thumb状态。 R0[0]=0 – 从Thumb状态切换到RAM状态。</li></ul><p><strong>RAM复位后的状态</strong><br>ARM处理器复位后的状态都是ARM状态<br><strong>BootLoader</strong></p><p><strong>U-BOOT</strong></p><ul><li>Linux中引导程序加载时所支持不同体系结构处理器种类最多的Bootloader 是- U-BOOT。</li><li>全称universal-Boot-Loader</li><li>支持PowerPC、x86、ARM等多种体系结构的处理器</li><li>支持嵌入式Linux、VxWorks、QNX、RTEMS、Windows CE等操作系统<br>采用两个阶段完成操作系统的引导加载</li><li>引导加载程序主要完成：加电自检、外设存在自检<em>、内存地址映射、初始化外围设备、内存寻址定位、加载并启动操作系统</em></li><li>BootLoader通常分为stage1和stage2两大部分。依赖于CPU的体系结构，比如设备初始化代码通常放在stage1中，且使用汇编语言实现，以达到短小精悍的目的。stage2通常用于C语言实现更复杂的功能，同时代码也具有更好的可读性和可移植性。</li><li>BootLoader的stage1的基本步骤是：基本硬件初始化，为加载stage2准备RAM空间，拷贝stage2的执行代码到RAM空间中，设置栈区指针SP，跳转到stage2的C程序入口点。</li></ul><p><strong>作用</strong></p><ul><li>改变程序大小端排序</li><li>关闭看门狗</li><li>屏蔽中断</li><li>设置各个时钟</li><li>设置从SLEEP或者IDLE启动时的程序</li><li>初始化SDRAM</li><li>设置各模式指向的堆栈</li><li>设置好中断向量表</li><li>判断是从NOR FLASH（行读写，较慢）还是NAND FLASH（页读写）启动</li><li>将文件拷到SDRAM中</li></ul><p><strong>操作系统</strong><br>IOS 的前身是 UNIX-BSD（<strong>宏内核架构</strong>，但是是微内核操作系统）<br><strong>内核的概念</strong><br>内核提供<strong>任务调度、任务间通信与同步、任务管理、时间管理和存储管理。</strong><br>典型的单片机程序在程序指针复位后，首先进行堆栈、中断、中断向量、定时器、串行口等接口设置、初始化数据存储区和显示内容，然后就来到了一个监测、等待或空循环，在这个循环中，CPU可以监视外设、响应中断或用户输入。 这段主程序可以看作是一个内核，内核负责<strong>系统的初始化和开放、调度其它任务</strong>，相当于C语言中的主函数。</p><p>现代操作系统设计中，为减少系统本身的开销，往往将一些与硬件紧密相关的（如中断处理程序、设备驱动程序等）、基本的、公共的、运行频率较高的模块（如时钟管理、进程调度等）以及关键性数据结构独立开来，使之常驻内存，并对他们进行保护。通常把这一部分称之为操作系统的内核。<br><strong>Linux</strong></p><ul><li>UCLinux、RTLinux、uC/OS - II是开源嵌入式操作系统</li><li>Linux最初以Unix为原型，以实现POSIX标准作为其目标。</li><li>OS服务组件、用户进程、Linux内核、硬件</li><li>系统调用是Linux中用户进程和操作系统之间的重要接口！</li></ul><p><strong>Linux和Unix</strong><br>其两者源码是完全不相同的，尽管函数和命令的功能处理结果、函数名称和参数十分相同，以及Unix的行命令、驱动程序和应用程序在Linux上能够运行。</p><p>Linux运行效率没有Unix高！<br><strong>Linux命令</strong></p><p>arm - linux - gcc交叉编译器来编译应用程序</p><p>要对一个应用程序进行调试排错，应在编译指令中加g参数对它进行编译<br>Linux内核主要由5个子系统组成</p><ul><li>进程调度（SCHED）</li><li>内存（任务）管理（MM）</li><li>虚拟文件系统（VFS）</li><li>网络接口（NET）</li><li>进程间通信（IPC）</li></ul><p>进程调度模块负责控制进程对CPU资源的使用，所采取的调度策略是使得各个进程能够平均访问CPU，同时保证内核能及时地执行硬件操作。</p><p>内存管理模块的功能之一是屏蔽各种硬件接口内存结构的差异并向上返回一个统一的访问接口</p><p>网络接口模块包含网络接口驱动程序</p><p>支持进程之间的各种通信机制，其通信机制包括：信号、管道、消息队列、信号量、共享内存、套接字（socket）<br><strong>微内核和宏内核</strong><br><strong>微内核特征</strong></p><ul><li>内核小巧，传统操作系统中的许多部分都被移出内核。</li><li>接口一致，所有进程请求使用统一接口，进程不区分内核模式和用户模式服务。</li><li>各个功能模块之间松散耦合，只完成服务功能，系统管理功能交给一个或多个特权服务程序。</li><li>微内核扩充方便，但是各个功能之间的切换引起的开销很大！</li></ul><p>属于微内核的典型嵌入式操作系统有：Symbian、VxWorks、QNX、uC/OS - II、IOS，而Symbian是普通实时操作系统<br>VxWorks收取授权费和版权费。<br>VxWokrs用于尖端科技中<br><strong>宏内核</strong></p><ul><li>传统操作系统常采用的结构</li><li>应用程序效率高</li><li>切换开销小</li><li>对外来时间反应速度快</li><li>内存大</li><li>拓展性不高，维护困难 </li><li>可预测性较低</li><li>可靠性较低</li></ul><p>Android OS是典型的宏内核操作系统</p><p>宏内核又称为单内核！<br><strong>Tiny OS</strong><br>是开放源代码操作系统，属于深度轻量级的操作系统，专为嵌入式无线传感器网络设计，功耗较低，特别适合传感器这种受内存，功耗限制的设备。</p><p>轻线程，主动消息和组件化编程。<br><strong>QNX</strong><br>符合POSIX基本标准和实时标准</p><p>微内核操作系统</p><p>内核提供四种服务：进程调度，进程间通信，底层网络通信和中断处理<br><strong>uC/OS-II</strong></p><ul><li>抢占式实时操作系统</li><li>抢占式实时操作系统且每个任务都有自用栈</li><li>使用它的栈空间校验函数，可以确定每个任务到底需要多少栈空间</li><li>该系统不包含设备驱动程序，只是一个纯内核</li><li>不支持时间片轮转调度，所以赋给每个任务的优先级是不相同的</li><li>允许每个任务之间有不同的栈空间</li><li>升级版的UC/OS - III是商用操作系统</li><li>II 具有良好的可剪裁性和可移植性</li><li>能够支持的任务数最多是64（保留8个给系统，实际剩下56个）</li><li>最多允许的中断嵌套层数可以达到255层</li><li>软件结构一般具有：应用软件层，API层，内核层和设备驱动层</li><li>该系统能提供周期性时钟信号（时钟节拍），用于实现任务的正确延时和超时确认，节拍率在10~100Hz之间</li><li>用户必须在多任务调度启动以后再使能时钟节拍中断</li><li>在中断返回之前，必须调用退出中断函数 voidIntExit(void)</li><li>互斥信号量可以解决优先级反转的问题</li><li>事件控制块用以对信号的管理</li><li>任务管理中空闲任务是系统创建的第一个任务（空闲任务永远不会处于挂起态，还可能运行态，即使优先级最低，一旦其他任务都被堵塞他就可以执行了！）</li><li>中断服务子程序的伪码结构：保存全部CPU寄存器到栈，调用OSIntEnter()或者OSIntNesting变量加1，执行中断服务代码或发出IPC信息通知特定任务去执行中断服务，调用OSIntExit()函数，恢复所有CPU寄存器，执行中断返回指令。</li></ul><p>uC/OS-II 移植到一个 嵌入式系统电路板上正常运行，必须具备的条件</p><ul><li>处理器的C编译器能产生可重入代码，且用C语言就可以打开和关闭中断。</li><li>处理器支持中断，并且能产生定时中断。（通常在10至100Hz之间）。</li><li>处理器支持能够容纳一定量数据（可能几千字节）的硬件栈区。</li></ul><p>uC/OS-II 保护任务之间的共享数据和提供任务之间的通信，可达到保护目的方法通常有</p><ul><li>利用宏OS_ENTER_CRITICAL()和OS_EXIT_CRITCAL来打开和关闭中断。</li><li>利用函数OSSchedLock()和OSSchedUnlock()对任务调度函数上锁和开锁。</li><li>利用信号量、互斥量、邮箱和消息队列进行任务间通信。</li></ul><p>系统启动过程中，Bootloader执行完毕后，调用应用程序主文件（通常是main.c）里的main函数。main函数在执行过程中除了用户函数和硬件初始化函数之外，需要执行下面三个重要函数：OSInit() -&gt; OSTaskCreate() -&gt; OSStart()(注意先后顺序)<br>OSInit()函数先建立最初的任务就绪表，然后建立4个空白的数据链表，即：任务控制块链表，事件控制块链表、标志链表、内存控制块链表。<br>系统中任务的五种状态</p><ul><li>休眠态（任务停留在内存中，还没有交给内核管理。）</li><li>就绪态（该任务已经准备好，可以运行了，但是由于任务的优先级比正在运行任务的优先级低，还暂时不能运行。）（还有一种情况被更高优先级打断！）</li><li>运行态（任务得到了CPU的控制权正在运行之中）</li><li>挂起态</li><li>被中断态（发生中断执行相应的中断服务，原来在正在运行后的任务暂时停止运行，进入被中断状态）</li></ul><p>一些系统函数</p><ul><li>OSTaskCreate() - 任务创建相关</li><li>OSCtxSw() - 真正实现任务切换的函数</li><li>OSIntExit() - 中断级的调度</li><li>OSTickISR() - 时钟节拍中断服务子程序，与时间管理相关</li><li>OSSched() - 任务前导函数，任务级的调度函数</li></ul><p>判断任务调度的三个条件是：</p><ul><li>中断嵌套层数共享全程变量OSIntNesting = 0，也就是所有的ISR已经执行完毕</li><li>任务调度加锁层数共享全程变量OSLockNesting = 0，也就是调度没有被禁止</li><li>就绪表找到最高优先级比当前任务的优先级高</li></ul><p>OSIntExit() - 中断级的调度函数</p><p>系统事件控制块的相关函数</p><ul><li>OSSemCreate()(信号量创建)</li><li>OSMutexCreate()(创建互斥体)</li><li>OSMboxCreate()(建立一个邮箱)</li><li>OSQCreate()(创建事件控制块)</li></ul><p>就绪任务登记在就绪表中，OSRdyTbl[ ] 是就绪表的位图映像矩阵，每一位代表了一个优先级任务的就绪状态，成为就绪位，该矩阵最多有64位。 </p><p>一些系统文件</p><ul><li>OS_CPU_C.C - 创建任务的自用栈空间、定义用户接口的hook原型</li><li>OS_CORE.C - 核心调度代码，包括系统初始化、启动多任务调度开始运行、任务创建管理与调度、TCB初始化、就绪表初始化、ECB初始化、任务事件就绪表、空闲任务</li><li>OS_MEM.C - 内存管理，包括创建分区，获得存储块</li><li>OS_TASK.C - 任务管理，包括改变一个任务的优先级、创建或者删除一个任务，恢复一个被挂起的任务</li></ul><p>uC/OS系统时钟内核的基本功能（通过GLIBC调用通用函数和内核的内部功能）</p><ul><li>任务管理</li><li>时间管理</li><li>内存管理</li><li>任务调度</li><li>任务间通信和同步</li></ul><p><strong>实时操作系统与非实时操作系统</strong><br>实时系统</p><ul><li>民航导航系统</li><li>防空预警系统</li><li>电力输送控制系统</li></ul><p>非实时</p><ul><li>视频播放系统</li><li>博客发布系统</li><li>手机交互式城市交通导航系统</li></ul><p><strong>实时操作系统</strong><br>RTOS响应中断请求并且完成相应的中断服务子函数的时间非常快！精细衡量这个时间一致性变化的术语是抖动！</p><p>中断服务子函数也是可以调用函数然后进行事件处理的，中断服务子程序返回的最后一步执行中断返回指令。<br>RTOS特征(主要特征是能够及时响应外部发生的随机任务请求并且能够在规定的时限内完成任务。)（不包括轮转调度）</p><ul><li>异步IO和中断处理能力</li><li>任务切换时间和中断延迟时间确定</li><li>优先级中断和调度</li><li>抢占式调度</li><li>内存锁定</li><li>连续文件</li><li>同步</li></ul><p><strong>RTOS的实时性能主要由三个指标衡量</strong></p><p>响应时间（包括中断延迟时间和任务切换时间）（任务切换时间又包括人物抢占时间）</p><p>吞吐量</p><p>生存时间</p><ul><li>响应时间有两个指标 - 中断延迟时间和任务切换时间</li><li>实时系统对时间约束要求的严格性，使可预测性成为实时系统的一项重要性能要求，它是指RTOS能够对外部事件的响应时间和实时任务的执行时间进行判断，以确定被时间触发的实时任务能否在规定的时间内完成。</li><li>一般按照相应时间能将实时系统分为三类：强实时系统，其相应时间一般在ms级或us级；普通实时操作系统一般在s级，弱实时系统一般在数十s级。</li></ul><p><strong>任务时限有两种</strong></p><ul><li>截止时间：任务开始执行时间到任务必须完成的时间间隔。</li><li>任务执行预设：又叫任务最快完成时间，这是在无中断响应情况下的任务最快执行时间。</li></ul><p><strong>硬实时操作系统和软实时操作系统</strong></p><ul><li>任务执行时间超过截止时间系统的总损益就为负，这种实时系统成为硬实时系统。而且伴随有严重的后果，比如飞机控制器、核反应堆处理装置。</li><li>软实时操作系统超过时限并不会造成严重的影响比如：DVD播放机。</li></ul><p><strong>存储器</strong><br>半导体存储器芯片的存储容量取决于该芯片的地址总线的条数和数据总线的位数。</p><p>存储器带宽与存储器总线的工作频率有关，也与数据线的位数和每个总线周期的传输次数有关！</p><p>系统正在运行的程序的大部分数据和代码存放在主存储器（内存）中</p><p>系统尚未运行的程序的大部分数据和代码存放在外部存储器中<br><strong>分类</strong></p><p>按照存取特性分为：RAM和ROM</p><p>按照物理位置分为：片内存储器和片外存储器以及外部存储器</p><p>按照存储信息的类型分为：程序存储区和数据存储器<br><strong>RAM</strong></p><p>RAM - 高速读取， DRAM - 高集成度</p><p>RAM 通常又有DRAM和SRAM之分，SRAM较DRAM电路复杂，但是速度更快，高速缓冲区(cache)就是典型的SRAM。 SRAM的复杂决定了它做不大，至多几十K。</p><p>内存条就是DRAM，速度较SRAM慢，但是可以做的很大，比如内存条就是典型的DRAM，其容量就上G了。</p><p>FRAM - 铁电随机存取存储器，MRAM - 磁性随机存取存储器。</p><p>（以上两个随机存储器是非易失性存储器）<br><strong>FLASH</strong><br>Flash闪存有两大类，或非型（NOR Flash）和与非型（NAND Flash）。</p><p>或非以字节为单位进行随机存取，存储在里面的程序可以被CPU执行。与非以页为单位进行存取，速度较前者慢。</p><p>与非门读出程序或数据时，是先将其预存入RAM，然后才被使用的。虽然速度较慢，但是其寿命，容量成本等方面有很大优势，常用的U盘基本都是NAND Flash。<br><strong>DDR</strong><br>DDR - dual data rate - 双倍数据速率</p><p>DDR2 - 使原来DDR可预取读取2位变成可预取读取4位或8位，把DDR的数据传输速率又提升了两倍或四倍<br><strong>USB</strong><br>USB2.0 的速度可达到 480Mb/s</p><p>USB3.0的速度可达到 5Gb/s, 即640MB/s</p><p>半双工差分方式通信<br><strong>编码**</strong>ASCII**<br>ASCII共128个字符，96个可打印字符，32个控制字符。</p><p>ASCII是7位编码，但在计算机里用一个字节存放（计算机最基本的存储和处理单位）</p><p>每个字节多出的1位在计算机内部常保持为0，在数据传输中是奇偶校验位。<br><strong>汉字编码</strong><br>GB2312 – 两字节编码（每个字节最高位默认为1），包含常用的中国汉字和图形符号。</p><p>GB18030 与国际Unicode相兼容。单字节对应ASCII，双字节对应汉字（GB2312在这完全适用，但是比它范围广），其余四字节对应其他字符。<br><strong>Unicode</strong><br>UTF-8 – 单字节可变长编码，单字节向下兼容ASCII，音节文字对应两字节，CJK汉字(china japan koera 中日韩汉字)对应三字节，其余对应四字节。Linux 常用。</p><p>UTF-16 – 双字节可变长编码，CJK汉字及常用字符两字节，其余四字节。JAVA .NET 常用。<br><strong>同步IO和异步IO</strong><br>CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。<br>在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。<br>多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。<br>另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。<br><strong>指令相关</strong><br>子程序返回调用程序除了MOV PC, LR。还可以MOV R15, LR</p><p>汇编语言调用一个名为My的子程序的指令为： BL My 子程序返回调用程序的指令为：MOV PC, LR。</p><p>Thumb - 2指令集中关外部中断使用的指令是：CPSID I。开外部中断的指令为：CPSIE I。</p><p>EQ表示相等，NE表示不等</p><p>RAM汇编程序采用分支指令B</p><p>子程序调用指令BL</p><p>条件转移指令BX</p><p>RAM汇编中没有专门的指令实现循环，一般采用比较指令CMP、ADD、SUB等才能产生条件的指令，然后再通过带状态的条件转移指令BX来实现。</p><p>指令后面加个！表示更新基地址寄存器符号</p><p>寄存器间接寻址就是以寄存器中的值作为操作数地址，而操作数本身存放在存储器中。用于间接寻址的寄存器必须用[ ] 括起来</p><p>Test EQU 50 定义 标号 Test的值为50!</p><p>RAM完成有条件无符号加法运算，并更新CPSR中的状态，条件如果是相等，要求指令执行R1+R2，结果放入R3中，则这条指令ADDCEQ R3, R1, R2。如果条件是大于，要求执行R1 - R2，结果放入R3，则该指令是SUBHIS R3, R1, R2<br><strong>指令的条件码总结</strong></p><ul><li>EQ - 相等</li><li>NE - 不等</li><li>MI - minus负数</li><li>PL - plus正数或0</li><li>vs - overflow set溢出</li><li>vc - overflow clear未溢出</li><li>GT - greater than带符号数大于</li><li>GE - greater and equal带符号数大于或等于</li><li>LT - lower than带符号数小于</li><li>LE - lower equal带符号数小于或等于</li><li>HI - high无符号数大于</li><li>CS - carry same无符号数大于或等于</li><li>CC - carry clear无符号数小于</li><li>LS - low and same无符号数小于或等于</li></ul><p><strong>常考指令</strong></p><p>LDR 字数据加载指令(存储器到寄存器的数据传送指令)</p><p>LDRB 字节数据加载指令</p><p>LDRH 半字数据加载指令</p><p>STR 字数据存储指令</p><p>STRB 字节数据存储指令<br>STRH 半字数据存储指令</p><ul><li>STR R0, [R1] - 将R0中一个字的数据，存入以R1的值为地址的存储器中。</li><li>LDR R0, [R1] - 以R1的值为地址的存储器中的字数据（为32位）读入寄存器R0</li><li>LDRH R0, [R1] -以R1的值为地址的存储器中的半字数据（为16位）读入寄存器R0</li><li>LDRB R0, [R1] -以R1的值为地址的存储器的字节数据（为8位）读入寄存器R0 </li><li>注意了，LDR R1, #0x12345678 LDR是加载存储指令，表示存储器到寄存器的数据传送，而#是立即数符号，表示立即数寻址。所以这样写是不正确的！</li></ul><p>ADC R1, R2, R3 表示 R1 = R2+R3+C（C表示进位）（ADD表示加法）（ADC表示）<br><strong>置1清0的操作</strong><br>常见的操作是：or可实现置1，and可实现清0。比如ORR R0，R0，＃00000003 该指令设置R0的0、1位，其余位保持不变。再比如AND R0，R0，＃FFFFFFFE实现R0的最低位清零。还有一个是用ARM的指令进行位清0，BIC R1, R1 #0X00000088<br><strong>立即数</strong></p><p>汇编语言中中操作数有三种：寄存器操作数、存储器操作数和立即数。</p><p>其中立即数相当于高级语言中的常量（常数），它是直接出现在指令中的数，不用存储在寄存器或存储器中的数，如指令ADD AL,06H中的06H即为立即数。<br><strong>大小端存储</strong><br>所谓的大端模式就是，低地址存储高位字节。<br>所谓的小端模式就是，低地址存储低位字节。<br><strong>计算机存储结构</strong><br>冯诺依曼，是一种程序指令储存和数据储存在一起的存储器结构<br>哈佛结构，是一种将程序指令储存和数据储存分开的存储器结构<br><strong>音频图像</strong></p><p><strong>音频</strong><br>数字音频的正确处理顺序是：取样 -&gt; 量化 -&gt; 编码</p><p>数字音频的主要参数：取样频率、量化位数、声道数目、使用的压缩编码方法、比特率</p><p>比特率（码率）计算方式：码率 = 取样频率×量化位数×声道数，压缩后的码率和压缩前的码率也就差一个压缩比。</p><p>mp3:MPEG - 1层③算法进行有损的压缩编码，以8~12倍的比率大幅度降低了声音的数据量<br><strong>图像</strong><br>包括BMP.、TIF、GIF、JPEG、PNG</p><p>数字图像的获取过程分为：扫描、分色、取样</p><p>GIF是互联网上广泛使用的一种图像文件格式，它的颜色数目较少，不超过256色，文件特别小，适合互联网传输</p><p>JPEG是静止图像数据压缩编码的国际标准，特别适合处理各种连续色调的彩色和灰度图像，算法复杂度适中，软硬件皆可实现。<br><strong>屏幕</strong></p><p><strong>触摸屏</strong></p><ul><li>电阻式触摸屏（软屏），结构简单价格低</li><li>电容式触摸屏（硬屏），结构复杂价格高</li><li>电容式触摸屏可以实现多点触摸和滑动操作</li><li>般写硬笔字的触摸屏是电阻屏</li></ul><p><strong>LCD显示屏</strong></p><ul><li>LCD显示屏自身不带控制器，没有驱动电路，仅仅是显示器件，价格最低</li><li>LCD显示模块内置LCD显示屏，控制器和驱动模块，有字符型和图形点阵型</li><li>PC机通常使用的是LCD显示器，除具备显示屏外，还包括驱动器，控制器以及外壳，是完整的LCD显示设备</li><li>DVI、VGA以及HDMI是一种接口标准</li></ul><p><strong>其他</strong></p><ul><li>微波通信：手机通信、卫星通信、无线局域网</li><li>调频广播属于短波以及超短波通信。</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 源码安装及卸载</title>
      <link href="/post/b01d34de.html"/>
      <content type="html"><![CDATA[<h2 id="1-源码的安装"><a href="#1-源码的安装" class="headerlink" title="1. 源码的安装"></a>1. 源码的安装</h2><p>源码安装的步骤大致分为四步：下载（download）、配置（configure）、编译（make）、安装（make install）。</p><a id="more"></a><ol><li><p>下载</p><p>下载源码的方式有许多，记录使用过的几个</p><ol><li><p>git 下载，已知源码的 github 地址可以执行</p><p><code>git clone 地址</code></p><p>下载，可以直接将源码文件夹下载至本地。</p></li><li><p>直接自行下载源码的压缩包，并解压</p><p>eg以<code>.tar</code>后缀的可以用<code>tar -xzf</code>命令解压</p></li><li><p>wget 下载：支持FTP及HTTP协议下载支持断点续传及代理服务器下载</p></li></ol></li><li><p>配置</p><p><strong>在源码目录执行<code>./configure --prefix=PATH  #PATH为自定义安装目录</code></strong></p><p>configure文件是一个可执行的脚本文件，它有很多选项，在待安装的源码目录下使用命令./configure –help可以输出详细的选项列表。</p><p>其中–prefix选项是配置安装目录，如果不配置该选项，安装后可执行文件默认放在/usr  /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr  /local/share，比较凌乱。</p><p>如果配置了–prefix，如：</p><p><code>$ ./configure --prefix=/usr/local/test</code></p><p>安装后的所有资源文件都会被放在/usr/local/test目录中，不会分散到其他目录。</p><p>使用–prefix选项的另一个好处是方便卸载软件或移植软件；当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；而移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统下）。</p><p>综上：**强烈建议配置 <code>--prefix</code>方便后期移植及卸载</p></li></ol><ol><li><p>编译</p><p><strong>执行<code>make</code></strong></p></li></ol><ol><li><p>安装</p><p>**执行`make install</p><p>为了记录安装详情方便后期，可输出安装日志，具体命令如下</p><p>make &gt;&amp; LOG_make &amp;<br>make install &gt;&amp; LOG_install &amp; </p></li></ol><h2 id="2-通过源码安装软件的卸载"><a href="#2-通过源码安装软件的卸载" class="headerlink" title="2. 通过源码安装软件的卸载"></a>2. 通过源码安装软件的卸载</h2><ol><li><p>如果configure时配置了 –prefix 则可以直接通过rm</p></li><li><p>如果源码包提供了make uninstall ，则可以通过在源码目录下执行<code>make uninstall</code>命令卸载</p></li><li><p>如果没有配置–prefix选项，源码包也没有提供make uninstall，则可以通过以下方式可以完整卸载：  </p><p>找一个临时目录重新安装一遍，如：<br>  <code>$ ./configure --prefix=/tmp/to_remove &amp;&amp; make install</code></p><p>然后遍历/tmp/to_remove的文件，删除对应安装位置的文件即可（因为/tmp/to_remove里的目录结构就是没有配置–prefix选项时的目录结构）。</p></li></ol><blockquote><p>参考地址：</p><p><a href="https://blog.csdn.net/u011334621/article/details/78506404" target="_blank" rel="noopener">https://blog.csdn.net/u011334621/article/details/78506404</a></p><p><a href="https://www.zhihu.com/question/20092756" target="_blank" rel="noopener">https://www.zhihu.com/question/20092756</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows常用命令（转载）</title>
      <link href="/post/67780d28.html"/>
      <content type="html"><![CDATA[<p>打开”<strong>运行</strong>“对话框（<strong>Win+R</strong>），输入cmd，打开控制台命令窗口…</p><p>也可以通过cmd /c 命令 和 cmd /k 命令的方式来直接运行命令</p><p>注：/c表示执行完命令后关闭cmd窗口；/k表示执行完命令后保留cmd窗口</p><a id="more"></a><h2 id="控制台命令窗口中一些技巧"><a href="#控制台命令窗口中一些技巧" class="headerlink" title="控制台命令窗口中一些技巧"></a><strong>控制台命令窗口中一些技巧</strong></h2><p>复制内容：右键弹出快捷菜单，选择“标记(K)”，然后选中所需复制的内容，然后右键即可</p><p>粘贴内容：右键弹出快捷菜单，选择“粘贴(P)”</p><p>在文件夹空白处按住Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”</p><p>使用上下方向键，翻看使用过的命令</p><p>tab补全功能</p><p>命令参数的路径：要使用反斜杠’ \ ‘，不要使用正斜杠’ / ‘   如：del d:\test2\file\my.txt</p><p>命令参数的路径：若存在空格，应使用双引号将路径引起来  如：del “d:\program files\file\my.txt”</p><p>文件及目录名中不能包含下列任何字符：\ / : * ? “ &lt; &gt; |</p><p><strong>rem</strong>  // 在批处理文件中添加注解，其后的命令不会被执行，但会回显</p><p><strong>::</strong>  // ::也可以起到rem的注释作用，且不会有回显</p><p>任何以冒号:开头的字符行, 在批处理中都被视作标号（label）, 而直接忽略其后的所有内容<br>有效标号：冒号后紧跟一个以字母数字开头的字符串，goto语句可以识别<br>无效标号：冒号后紧跟一个非字母数字的一个特殊符号，goto无法识别的标号，可以起到注释作用，::常被用作注释符号</p><h2 id="0-获取帮助"><a href="#0-获取帮助" class="headerlink" title="0. 获取帮助"></a><strong>0. 获取帮助</strong></h2><p><strong>command /?</strong>  // 查看command命令帮助说明</p><h2 id="1-中断命令执行"><a href="#1-中断命令执行" class="headerlink" title="1. 中断命令执行"></a><strong>1. 中断命令执行</strong></h2><p><strong>Ctrl + C</strong></p><h2 id="2-文件-目录"><a href="#2-文件-目录" class="headerlink" title="2. 文件/目录"></a><strong>2. 文件/目录</strong></h2><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd   切换目录"></a><strong>cd</strong>   切换目录</h3><p>例：cd   // 显示当前目录</p><p>例：cd ..   // 进入父目录</p><p>例：cd /d d:   // 进入上次d盘所在的目录（或在直接输入：d:）</p><p>例：cd /d d:\   // 进入d盘根目录</p><p>例：cd d: // 显示上次d盘所在的目录</p><p>例：cd /d d:\src // 进入d:\src目录</p><p>例：cd prj\src\view  // 进入当前目录下的prj\src\view文件夹</p><blockquote><p>其中 /d 的作用是转换盘符，也可直接输入盘符转换</p><p>eg: <code>D:</code>  或 <code>cd /d D:</code></p></blockquote><h3 id="pushd-popd-使用栈来维护当前目录"><a href="#pushd-popd-使用栈来维护当前目录" class="headerlink" title="pushd  popd  使用栈来维护当前目录"></a><strong>pushd  popd</strong>  使用栈来维护当前目录</h3><p>md d:\mp3 // 在C:\建立mp3文件夹<br>md d:\mp4       // 在D:\建立mp4文件夹<br>cd /d d:\mp4    // 更改当前目录为d:\mp4<br>pushd c:\mp3    // 将当前目录d:\mp4入栈，并切换当前目录为c:\mp3<br>popd  // 将刚才保存的d:\mp4弹栈，并设置为当前目录</p><h3 id="dir-显示目录中的内容"><a href="#dir-显示目录中的内容" class="headerlink" title="dir  显示目录中的内容"></a><strong>dir</strong>  显示目录中的内容</h3><p>例：dir   // 显示当前目录中的子文件夹与文件</p><p>例：dir /b  // 只显示当前目录中的子文件夹与文件的文件名</p><p>例：dir /p  // 分页显示当前目录中的子文件夹与文件</p><p>例：dir /ad  // 显示当前目录中的子文件夹</p><p>例：dir /a-d  // 显示当前目录中的文件</p><p>例：dir c:\test   // 显示c:\test目录中的内容</p><p>例：dir keys.txt  // 显示当前目录中keys.txt的信息</p><p>例：dir /S   // 递归显示当前目录中的内容</p><p>例：dir key*  // 显示当前目录下以key开头的文件和文件夹的信息</p><p>例：dir /AH /OS  // 只显示当前目录中隐藏的文件和目录，并按照文件大小从小到大排序</p><h3 id="tree-显示目录结构"><a href="#tree-显示目录结构" class="headerlink" title="tree 显示目录结构"></a><strong>tree</strong> 显示目录结构</h3><p>例：tree d:\myfiles  // 显示d:\myfiles目录结构</p><h3 id="ren-文件或目录重命名"><a href="#ren-文件或目录重命名" class="headerlink" title="ren  文件或目录重命名"></a><strong>ren</strong>  文件或目录重命名</h3><p>例：ren rec.txt rec.ini  // 将当前目录下的rec.txt文件重命名为rec.ini</p><p>例：ren c:\test test_01  // 将c盘下的test文件夹重命名为test_01</p><p>例：ren Logs.txt Logs-%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%.txt  // 将当前目录下的Logs.txt文件重命名为Logs-20150114_2135.txt或Logs-20150114_ 812.txt（注意：小时只有个位数时会多一个空格，可以使用字符串替换：将空格替换成0）</p><h3 id="md-创建目录"><a href="#md-创建目录" class="headerlink" title="md  创建目录"></a><strong>md</strong>  创建目录</h3><p>例：md movie music  // 在当前目录中创建名为movie和music的文件夹</p><p>例：md d:\test\movie  // 创建d:\test\movie目录</p><h3 id="rd-删除目录"><a href="#rd-删除目录" class="headerlink" title="rd  删除目录"></a><strong>rd</strong>  删除目录</h3><p>例：rd movie // 删除当前目录下的movie空文件夹</p><p>例：rd /s /q d:\test  // 使用安静模式删除d:\test（除目录本身外，还将删除指定目录下的所有子目录和文件）</p><h3 id="copy-拷贝文件"><a href="#copy-拷贝文件" class="headerlink" title="copy 拷贝文件"></a><strong>copy</strong> 拷贝文件</h3><p>例：copy key.txt c:\doc  // 将当前目录下的key.txt拷贝到c:\doc下（若doc中也存在一个key.txt文件，会询问是否覆盖）</p><p>例：copy jobs c:\doc  // 将当前目录下jobs文件夹中文件（不递归子目录）拷贝到c:\doc下（若doc中也存在相应的文件，会询问是否覆盖）</p><p>例：copy key.txt c:\doc\key_bak.txt  // 将当前目录下的key.txt拷贝到c:\doc下，并重命名为key_bak.txt（若doc中也存在一个key_bak.txt文件，会询问是否覆盖）</p><p>例：copy /Y key.txt c:\doc  // 将当前目录下的key.txt拷贝到c:\doc下（不询问，直接覆盖写）</p><p>例：copy key.txt +  // 复制文件到自己，实际上是修改了文件日期</p><p>例：copy /Y key1.txt + key2.txt key.txt  // 将当前目录下的key1.txt与key2.txt的内容合并写入key.txt中（不询问，直接覆盖写）</p><p>例：copy /B art_2.7z.* art_2.7z    // 将当前目录下的art_2.7z.开头的所有文件（按照名称升序排序）依次合并生成art_2.7z</p><p>例：copy /B art_2.7z.001+art_2.7z.002 art_2.7z    // 将当前目录下的art_2.7z.001、art_2.7z.002文件合并生成art_2.7z</p><h3 id="xcopy-更强大的复制命令"><a href="#xcopy-更强大的复制命令" class="headerlink" title="xcopy  更强大的复制命令"></a><strong>xcopy</strong>  更强大的复制命令</h3><p>例：xcopy c:\bat\hai d:\hello\ /y /h /e /f /c    // 将c:\bat\hai中的所有内容拷贝到d:\hello中  注意：需要在hello后加上\  表示hello为一个目录，否则xcopy会询问hello是F，还是D</p><p>例：xcopy c:\bat\hai d:\hello\ /d:12-29-2010  // 将c:\bat\hai中的2010年12月29日后更改的文件拷贝到d:\hello中</p><h3 id="move-移动文件"><a href="#move-移动文件" class="headerlink" title="move 移动文件"></a><strong>move</strong> 移动文件</h3><p>例：move *.png test  // 将当前目录下的png图片移动到当前目录下test文件夹中 （若test中也存在同名的png图片，会询问是否覆盖）</p><p>例：move /Y *.png test  // 将当前目录下的png图片移动到当前目录下test文件夹中 （不询问，直接覆盖写）</p><p>例：move 1.png d:\test\2.png  // 将当前目录下的1.png移动到d盘test文件夹中，并重命名为2.png （若test中也存在同名的png图片，会询问是否覆盖）</p><p>例：move test d:\new  // 若d盘中存在new文件夹，将当前目录下的test文件夹移动到d盘new文件夹中；若不存在，将当前目录下的test文件夹移动到d盘，并重命名为new</p><h3 id="del-删除文件-目录及子目录都不会删除"><a href="#del-删除文件-目录及子目录都不会删除" class="headerlink" title="del 删除文件 (目录及子目录都不会删除)"></a><strong>del</strong> 删除文件 (目录及子目录都不会删除)</h3><p>例：del test  // 删除当前目录下的test文件夹中的所有非只读文件（子目录下的文件不删除；删除前会进行确认；等价于del test*）</p><p>例：del /f test  // 删除当前目录下的test文件夹中的所有文件（含只读文件；子目录下的文件不删除；删除前会进行确认；等价于del /f test*）</p><p>例：del /f /s /q test d:\test2*.doc  // 删除当前目录下的test文件夹中所有文件及d:\test2中所有doc文件（含只读文件；递归子目录下的文件；删除前不确认）</p><p>++++++++++++++++++++++</p><p>/ar、/ah、/as、/aa 分别表示删除只读、隐藏、系统、存档文件<br>/a-r、/a-h、/a-s、/a-a 分别表示删除除只读、隐藏、系统、存档以外的文件</p><p>++++++++++++++++++++++</p><p>例：del /ar <em>.</em> // 删除当前目录下所有只读文件</p><p>例：del /a-s <em>.</em>  // 删除当前目录下除系统文件以外的所有文件</p><h3 id="replace-替换文件"><a href="#replace-替换文件" class="headerlink" title="replace 替换文件"></a><strong>replace</strong> 替换文件</h3><p>即使这个文件在使用，仍然可以替换成功</p><p>例：replace d:\love.mp3 d:\mp3   // 使用d盘下的love.mp3强制替换d盘mp3目录中的love.mp3文件</p><h3 id="mklink-创建符号链接"><a href="#mklink-创建符号链接" class="headerlink" title="mklink  创建符号链接"></a><strong>mklink</strong>  创建符号链接</h3><blockquote><p>Win7引入；创建的符号链接文件上会有一个类似快捷方式的箭头</p></blockquote><p>win7下的mklink命令通过指定参数可以建立出不同形式的文件或目录链接，分为硬链接(hard link)、符号链接(symbolic link)和目录联接(junction)三种。</p><h4 id="1-符号链接-symbolic-link"><a href="#1-符号链接-symbolic-link" class="headerlink" title="(1) 符号链接(symbolic link)"></a>(1) 符号链接(symbolic link)</h4><p>　建立一个软链接相当于建立一个文件（或目录），这个文件（或目录）用于指向别的文件（或目录），和win的快捷方式有些类似。</p><p>  删除这个链接，对原来的文件（或目录）没有影像没有任何影响；而当你删除原文件（或目录）时，再打开链接则会提示“位置不可用”。</p><h4 id="2-目录联接-junction"><a href="#2-目录联接-junction" class="headerlink" title="(2) 目录联接(junction)"></a>(2) 目录联接(junction)</h4><p>　作用基本和符号链接类似。区别在于，目录联接在建立时会自动引用原目录的绝对路径，而符号链接允许相对路径的引用。</p><h4 id="3-硬链接-hard-link"><a href="#3-硬链接-hard-link" class="headerlink" title="(3) 硬链接(hard link)"></a>(3) 硬链接(hard link)</h4><p>　建立一个硬链接相当于给文件建立了一个别名，例如对1.txt创建了名字为2.txt的硬链接；</p><p>  若使用记事本对1.txt进行修改，则2.txt也同时被修改，若删除1.txt，则2.txt依然存在，且内容与1.txt一样。</p><p>建立链接请注意：<br>a、建立文件或目录链接限于 NTFS 文件系统；符号链接（目录联接）的建立可以跨分区（如：在d盘可以建立c盘文件或目录的链接），硬链接只能建立同一分区内的文件指向<br>b、硬链接只能用于文件，不能用于目录；目录联接只能用于目录；符号链接则均可以；<br>c、硬链接不允许对空文件建立链接，符号（软）链接可以。</p><p>+++++++++++++++++++++++++++++++++</p><p>mklink [[/d] | [/h] | [/j]] Link Target</p><p>/d　　 创建目录符号链接。黙认为文件符号链接。<br>/h　　  创建硬链接，而不是符号链接。<br>/j　　　创建目录联接。<br>Link　　指定新的符号链接名称。<br>Target　指定新链接引用的路径(相对或绝对)。</p><p>+++++++++++++++++++++++++++++++++</p><p>例：mklink /j “C:\Users” “D:\Users”   // 创建D盘Users目录联接到C盘，并命名为Users</p><h3 id="attrib-查看或修改文件或目录的属性"><a href="#attrib-查看或修改文件或目录的属性" class="headerlink" title="attrib  查看或修改文件或目录的属性"></a><strong>attrib</strong>  查看或修改文件或目录的属性</h3><p>【A：存档  R：只读  S：系统  H：隐藏】</p><p>例：attrib 1.txt   // 查看当前目录下1.txt的属性</p><p>例：attrib -R 1.txt  // 去掉1.txt的只读属性</p><p>例：attrib +H movie  // 隐藏movie文件夹</p><p><strong>assoc</strong> 设置’文件扩展名’关联到的’文件类型’</p><p>例：assoc // 显示所有’文件扩展名’关联</p><p>例：assoc .txt      // 显示.txt代表的’文件类型’，结果显示.txt=txtfile</p><p>例：assoc .doc      // 显示.doc代表的’文件类型’，结果显示.doc=Word.Document.8</p><p>例：assoc .exe      // 显示.exe代表的’文件类型’，结果显示.exe=exefile</p><p>例：assoc .txt=txtfile  // 恢复.txt的正确关联</p><h3 id="ftype-设置’文件类型’关联到的’执行程序和参数’"><a href="#ftype-设置’文件类型’关联到的’执行程序和参数’" class="headerlink" title="ftype 设置’文件类型’关联到的’执行程序和参数’"></a><strong>ftype</strong> 设置’文件类型’关联到的’执行程序和参数’</h3><p>例：ftype // 显示所有’文件类型’关联</p><p>例：ftype exefile   // 显示exefile类型关联的命令行，结果显示 exefile=”%1” %*</p><p>例：ftype txtfile=C:\Windows\notepad.exe %1  // 设置txtfile类型关联的命令行为：C:\Windows\notepad.exe %1</p><p>当双击一个.txt文件时，windows并不是根据.txt直接判断用notepad.exe打开<br>而是先判断.txt属于txtfile’文件类型’；再调用txtfile关联的命令行：txtfile=%SystemRoot%\system32\NOTEPAD.EXE %1</p><h3 id="forfiles-递归目录执行命令"><a href="#forfiles-递归目录执行命令" class="headerlink" title="forfiles 递归目录执行命令"></a><strong>forfiles</strong> 递归目录执行命令</h3><p>例：forfiles /p . /m .svn /s /c “cmd /c svn up -r12005” // 在当前目录下查找含有.svn的文件或目录（递归子目录），并对该目录执行指定版本号svn更新</p><p>例：forfiles /p c:\myfiles /m .svn /s /c “cmd /c svn up -r12005” // 在c:\myfiles目录下查找含有.svn的文件或目录（递归子目录），并对该目录执行指定版本号svn更新</p><h2 id="3-文件查看"><a href="#3-文件查看" class="headerlink" title="3. 文件查看"></a><strong>3. 文件查看</strong></h2><h3 id="type-显示文本文件内容"><a href="#type-显示文本文件内容" class="headerlink" title="type 显示文本文件内容"></a><strong>type</strong> 显示文本文件内容</h3><p>例：type c:\11.txt   // 显示c盘中11.txt的文本内容</p><p>例：type conf.ini  // 显示当前目录下conf.ini的文本内容</p><p>例：type c:\11.txt | more  // 分页显示c盘中11.txt的文本内容</p><h3 id="more-逐屏的显示文本文件内容"><a href="#more-逐屏的显示文本文件内容" class="headerlink" title="more 逐屏的显示文本文件内容"></a><strong>more</strong> 逐屏的显示文本文件内容</h3><p>例：more conf.ini  //  逐屏的显示当前目录下conf.ini的文本内容   【空格：下一屏 q：退出 】</p><h2 id="4-注册表命令"><a href="#4-注册表命令" class="headerlink" title="4. 注册表命令"></a><strong>4. 注册表命令</strong></h2><h3 id="reg-注册表相关操作"><a href="#reg-注册表相关操作" class="headerlink" title="reg 注册表相关操作"></a><strong>reg</strong> 注册表相关操作</h3><p>参数说明：</p><p>KeyName [\Machine]FullKey<br>                      Machine为远程机器的机器名 - 忽略默认到当前机器。<br>                      远程机器上只有 HKLM 和 HKU。<br>                      FullKey  ROOTKEY+SubKey<br>                      ROOTKEY  [ HKLM | HKCU | HKCR | HKU | HKCC ]<br>                      SubKey   所选ROOTKEY下注册表项的完整名<br>  /v        所选项之下要添加的值名<br>  /ve      为注册表项添加空白值名&lt;无名称&gt;<br>  /t        RegKey 数据类型<br>                      [ REG_SZ    | REG_MULTI_SZ  | REG_DWORD_BIG_ENDIAN    |<br>                        REG_DWORD | REG_BINARY    | REG_DWORD_LITTLE_ENDIAN |<br>                        REG_NONE  | REG_EXPAND_SZ ]<br>                      如果忽略，则采用 REG_SZ<br>  /s        指定一个在 REG_MULTI_SZ 数据字符串中<br>                      用作分隔符的字符；如果忽略，则将””用作分隔符<br>  /d        要分配给添加的注册表ValueName的数据<br>  /f        不提示，强行改写现有注册表项</p><p>例：reg add “HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run” /v MyApp /t REG_SZ /d “c:\tools\myapp.exe” /f  // 强制添加一条开机启动c:\tools\myapp.exe程序的注册表项</p><p>例：reg add “HKLM\SOFTWARE\ScmClient” /v AgreementConfirmed /t REG_SZ /d 1 /f  // 解决32位xp打开ioa后，弹出的框关不掉问题</p><p>例：reg add “HKCU\ControlPanel\Desktop” /v WaitToKIllAppTimeOut /t REG_SZ /d 10000 /f // 强制添加一条加速关闭应用程序的注册表项</p><p>例：reg add “hkcu\software\Unity Technologies\Unity Editor 4.x” /v JdkPath_h4127442381 /t REG_SZ /f // 将JdkPath_h4127442381设置为空</p><p>例：reg add “HKCR*\shell\WinDbg\command” /t REG_SZ /d “\”D:\Program Files (x86)\windbg\windbg.exe\” -z \”%1\” “ /f    // 强制添加windbg打开dump文件到右键菜单的注册表项（不指明/v，键值将写入默认值名中）</p><p>例：reg add “HKCR*\shell\WinHex\command” /t REG_SZ /d “\”D:\software-setup\system\winhex\winhex.exe\”  \”%1\” “ /f    // 强制添加winhex到右键菜单的注册表项（不指明/v，键值将写入默认值名中）</p><p>注册表中%1 %2 %3 %4的含义：<br>–  %1表示文件列表，%2表示默认打印机，%3表示驱动器，%4表示端口</p><p>例：reg  add “hkcu\software\microsoft\windows\currentversion\internet settings”  /v AutoConfigURL /t REG_SZ /d “<a href="http://txp-01.tencent.com/proxy.pac&quot;" target="_blank" rel="noopener">http://txp-01.tencent.com/proxy.pac&quot;</a> /f  // 为IE设置代理：<a href="http://txp-01.tencent.com/proxy.pac" target="_blank" rel="noopener">http://txp-01.tencent.com/proxy.pac</a></p><p>例：reg add “hkcu\software\Sysinternals\Process Monitor” /v EulaAccepted /t REG_DWORD /d 1 /f  // 为Procmon.exe工具（Process Monitor为其属性面板上的描述名）添加License同意</p><p>例：reg delete “HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run” /v MyApp /f  // 强制删除值名的MyApp的注册表项</p><p>例：reg delete “HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe” /f  // 强制删除让任务栏里的任务管理器为灰色的注册表项</p><p>例：reg delete HKEY_CURRENT_USER\Environment /v HTTP_proxy /f  // 删除http代理</p><p>例：reg delete HKEY_CURRENT_USER\Environment /v HTTPS_proxy /f  // 删除https代理</p><p>例：reg copy “hkcu\software\microsoft\winmine” “hkcu\software\microsoft\winminebk” /s /f  // 强制复制winmine下所有的子项与值到winminebk中</p><p>例：reg export “hkcu\software\microsoft\winmine” c:\regbak\winmine.reg  // 导出winmine下所有的子项与值到c:\regbak\winmine.reg文件中</p><p>例：reg import c:\regbak\winmine.reg  // 导入c:\regbak\winmine.reg文件到注册表中</p><p>例：reg query “HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\IEXPLORE.EXE” /s   // 查询ie的安装路径</p><p>例：reg query HKCR.dsw /ve  // 查询.dsw默认值</p><p>例：reg query HKEY_CURRENT_USER\Software\Tencent\QQGame\SYS /v GameDirectory  // 查询QQGame安装路径</p><h2 id="5"><a href="#5" class="headerlink" title="5. @#@"></a><strong>5. @#@</strong></h2><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a><strong>&amp;</strong></h3><blockquote><p>顺序执行多条命令，而不管命令是否执行成功</p></blockquote><p>例：cd /d d:\src&amp;work.exe /o c:\result.txt  // 先将当前工作目录切换到d:\src下，然后执行work.exe /o c:\result.txt命令</p><h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a><strong>&amp;&amp;</strong></h3><blockquote><p>顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令</p></blockquote><p>例：find “ok” c:\test.txt &amp;&amp; echo 成功 // 如果找到了”ok”字样，就显示”成功”，找不到就不显示</p><h3 id=""><a href="#" class="headerlink" title="||"></a><strong>||</strong></h3><blockquote><p>顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令</p></blockquote><p>例：find “ok” c:\test.txt || echo 不成功   // 如果找不到”ok”字样，就显示”不成功”，找到了就不显示</p><h3 id="-1"><a href="#-1" class="headerlink" title="|"></a><strong>|</strong></h3><blockquote><p>管道命令</p></blockquote><p>例：dir <em>.</em> /s/a | find /c “.exe”   // 先执行dir命令，然后对输出结果（stdout）执行find命令（输出当前文件夹及所有子文件夹里的.exe文件的个数）</p><p>例：dir <em>.</em> /s/a 2&gt;&amp;1 | find /c “.exe”   // 先执行dir命令，然后对输出结果（stdout）和错误信息（stderr）执行find命令（输出当前文件夹及所有子文件夹里的.exe文件的个数）</p><h3 id="gt"><a href="#gt" class="headerlink" title="&gt;"></a><strong>&gt;</strong></h3><blockquote><p>将当前命令输出以覆盖的方式重定向</p></blockquote><p>例：tasklist &gt; p1.txt   // 将tasklist的输出结果（stdout）以覆盖的方式重定向到p1.txt文件中（注：tasklist的输出结果就不会打印到屏幕上了）</p><p>例：tasklist 1&gt; p1.txt  // 等同于：tasklist &gt; p1.txt</p><p>例：dir bin 2&gt; p1.txt  // 输出结果（stdout）打印在屏幕上，错误信息（stderr）以覆盖的方式重定向到p1.txt中（注：bin目录不存在时，会输出错误信息）</p><p>例：dir bin &gt; p1.txt 2&gt;&amp;1  // 将错误信息（stderr）重定向到输出结果（stdout），然后将输出结果（stdout）以覆盖的方式重定向到p1.txt中（注：bin目录不存在时，会输出错误信息）</p><p>例：dir bin 2&gt; p1.txt 1&gt;&amp;2  // 将输出结果（stdout）重定向到错误信息（stderr），然后将错误信息（stderr）以覆盖的方式重定向到p1.txt中（注：bin目录不存在时，会输出错误信息） 注：与上条命令结果一致</p><p>例：tasklist &gt;nul   // 屏幕上不打印tasklist的输出结果（stdout），错误信息（stderr）仍会打印</p><p>例：dir bin 2&gt;nul   // 屏幕上不打印命令的错误信息（stderr），输出结果（stdout）仍会打印（注：bin目录不存在时，会输出错误信息）</p><p>例：dir bin &gt;nul 2&gt;&amp;1   //  将命令的错误信息（stderr）重定向到输出结果（stdout），然后不打印输出结果（stdout）【屏幕上错误信息（stderr）和输出结果（stdout）都不打印】（注：bin目录不存在时，会输出错误信息）</p><p>例：dir bin 2&gt;nul 1&gt;&amp;2   //  将命令的输出结果（stdout）重定向到错误信息（stderr），然后不打印错误信息（stderr）【屏幕上错误信息（stderr）和输出结果（stdout）都不打印】（注：bin目录不存在时，会输出错误信息）</p><h3 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a><strong>&gt;&gt;</strong></h3><blockquote><p> 将当前命令输出以追加的方式重定向</p></blockquote><p>例：tasklist &gt;&gt; p2.txt   // 将tasklist的输出结果（stdout）以追加的方式重定向到p2.txt文件中（注：tasklist的输出结果就不会打印到屏幕上了）</p><p>例：tasklist 1&gt;&gt; p2.txt  // 等同于：tasklist &gt;&gt; p2.txt</p><p>例：dir bin 2&gt;&gt; p2.txt  // 输出结果（stdout）打印在屏幕上，错误信息（stderr）以追加的方式重定向到p2.txt中（注：bin目录不存在时，会输出错误信息）</p><p>例：dir bin &gt;&gt; p2.txt 2&gt;&amp;1  // 将错误信息（stderr）重定向到输出结果（stdout），然后将输出结果（stdout）以追加的方式重定向到p2.txt中（注：bin目录不存在时，会输出错误信息）</p><p>例：dir bin 2&gt;&gt; p2.txt 1&gt;&amp;2  // 将输出结果（stdout）重定向到错误信息（stderr），然后将错误信息（stderr）以追加的方式重定向到p2.txt中（注：bin目录不存在时，会输出错误信息） 注：与上条命令结果一致</p><h3 id="lt"><a href="#lt" class="headerlink" title="&lt;"></a><strong>&lt;</strong></h3><blockquote><p>从文件中获得输入信息，而不是从屏幕上，一般用于date time label等需要等待输入的命令</p></blockquote><p>例：date &lt;temp.txt  // temp.txt中的内容为2005-05-01</p><table><thead><tr><th>编号</th><th>Handle</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>stdin</td><td>键盘输入</td></tr><tr><td>1</td><td>stdout</td><td>在命令提示窗口上打印输出结果（默认）</td></tr><tr><td>2</td><td>stderr</td><td>在命令提示窗口上打印错误信息（默认）</td></tr><tr><td>3-9</td><td>undefined</td><td>应用程序自己定义和指定</td></tr></tbody></table><h3 id="命令修饰符"><a href="#命令修饰符" class="headerlink" title="@   命令修饰符"></a><strong>@</strong>   命令修饰符</h3><blockquote><p>在执行命令前，不打印出该命令的内容</p></blockquote><p>例：@cd /d d:\me   // 执行该命令时，不打印出命令的内容：cd /d d:/me</p><h3 id="-2"><a href="#-2" class="headerlink" title=","></a><strong>,</strong></h3><blockquote><p>在某些特殊的情况下可以用来代替空格使用</p></blockquote><p>例：dir,c:\   // 相当于：dir c:\</p><h3 id="-3"><a href="#-3" class="headerlink" title=";"></a><strong>;</strong></h3><blockquote><p>当命令相同的时候,可以将不同的目标用;隔离开来但执行效果不变。如执行过程中发生错误则只返回错误报告但程序还是会继续执行</p></blockquote><p>例：dir c:\;d:\;e:\   // 相当于顺序执行：dir c:\    dir d:\     dir e:\</p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a><strong>echo</strong></h3><blockquote><p><strong>echo.</strong>   // 输出一个”回车换行”，空白行</p><p><strong>echo off</strong>   // 后续所有命令在执行前，不打印出命令的内容</p><p><strong>echo on</strong>   // 后续所有命令在执行前，打印出命令的内容</p><p><strong>echo 123</strong>   // 输出123到终端屏幕</p><p><strong>echo “Hello World!!!”</strong>   // 输出Hello World!!!到终端屏幕</p><p><strong>echo %errorlevel%</strong>   // 每个命令运行结束，可以用这个命令行格式查看返回码；默认值为0，一般命令执行出错会设errorlevel为1</p><p><strong>echo test &gt; p1.txt</strong>  // 输出test的字符串到当前目录中的p1.txt文件中（以覆盖的方式）</p></blockquote><h3 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h3><blockquote><p>显示当前用户所有的环境变量</p><p><strong>set path</strong> // 查看path的环境变量值（准确的说是查看以path开头的环境变量）</p><p><strong>set path=</strong>    // 清空path变量</p><p><strong>set path=d:\execute</strong>  // 将path变量设置为d:\execute（注：修改的path只会影响当前回话，也不会存储到系统配置中去；当前cmd窗口关闭，新设置的path也就不存在了）</p><p><strong>set path=%path%;d:\execute</strong>   // 在path变量中添加d:\execute（注：修改的path只会影响当前回话，也不会存储到系统配置中去；当前cmd窗口关闭，新设置的path也就不存在了）</p></blockquote><h3 id="path"><a href="#path" class="headerlink" title="path"></a><strong>path</strong></h3><blockquote><p>显示当前path变量的值</p><p><strong>path ;</strong> // 清除所有搜索路径设置并指示cmd.exe只在当前目录中搜索</p><p><strong>path d:\xxx;%PATH%</strong>  // 将d:\xxx路径添加到path中</p></blockquote><p>-————————————————–</p><p><strong>set p=aa1bb1aa2bb2</strong> // 设置变量p，并赋值为aa1bb1aa2bb2</p><p><strong>echo %p%</strong>                // 显示变量p代表的字符串，即aa1bb1aa2bb2</p><p><strong>echo %p:~6%</strong>             // 显示变量p中第6个字符以后的所有字符，即aa2bb2</p><p><strong>echo %p:~6,3%</strong>           // 显示第6个字符以后的3个字符，即aa2</p><p><strong>echo %p:~0,3%</strong>           // 显示前3个字符，即aa1</p><p><strong>echo %p:~-2%</strong>            // 显示最后面的2个字符，即b2</p><p><strong>echo %p:~0,-2%</strong>          // 显示除了最后2个字符以外的其它字符，即aa1bb1aa2b</p><p><strong>echo %p:aa=c%</strong>           // 用c替换变量p中所有的aa，即显示c1bb1c2bb2</p><p><strong>echo %p:aa=%</strong>            // 将变量p中的所有aa字符串置换为空，即显示1bb12bb2</p><p><strong>echo %p:*bb=c%</strong>          // 第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2</p><p><strong>set p=%p:*bb=c%</strong>         // 设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2</p><p><strong>set /a p=39</strong>             // 设置p为数值型变量，值为39</p><p><strong>set /a p=39/10</strong>          // 支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3</p><p><strong>set /a p=p/10</strong>           // 用 /a 参数时，在 = 后面的变量可以不加%直接引用</p><p><strong>set /a p=”1&amp;0”</strong>          // &amp;运算要加引号。其它支持的运算符参见set/?</p><p>-————————————————–</p><p><strong>cls</strong>  清除屏幕</p><p><strong>ver</strong>  显示当前windows系统的版本号</p><p><strong>winver</strong>  弹框显示当前windows系统信息</p><p><strong>vol</strong>  显示当前分区的卷标</p><p><strong>label</strong>  显示当前分区的卷标，同时提示输入新卷标</p><p><strong>label c:system</strong>  设置c盘的卷标为system</p><p><strong>time</strong>  显示或设置当前时间</p><p>例：time /t  // 显示当前时间</p><p>例：time   // 设置新的当前时间（格式：hh:mm:ss），直接回车则表示放弃设置</p><p><strong>date</strong>  显示或设置当前日期</p><p>例：date /t  // 显示当前日期</p><p>例：date   // 设置新的当前日期（格式：YYYY/MM/DD），直接回车则表示放弃设置</p><p><strong>title</strong> 正在做命令行测试  // 修改当前cmd窗口的标题栏文字为正在做命令行测试</p><p><strong>prompt orz:</strong>   // 将命令提示符修改为orz:</p><p><strong>print 1.txt</strong>  // 使用设置好的打印机来打印1.txt文本文件</p><p><strong>call ff.bat</strong>   // 调用执行ff.bat脚本（ff.bat脚本执行完原脚本才会往下执行）</p><p><strong>start</strong>  运行某程序或命令</p><p>例：start /max notepad.exe  // 最大化的方式启动记事本</p><p>例：start /min calc.exe   // 最小化的方式启动计算器</p><p>例：start /min “” d:\Proxifier.exe   // 最小化的方式启动Proxifier代理工具</p><p>例：start  tasklist  // 启动一个cmd实例窗口，并运行tasklist</p><p>例：start explorer f:\  // 调用资源管理器打开f盘</p><p>例：strat iexplore “<a href="http://www.qq.com&quot;" target="_blank" rel="noopener">www.qq.com&quot;</a>  // 启动ie并打开<a href="http://www.qq.com网址" target="_blank" rel="noopener">www.qq.com网址</a></p><p>例：start ff.bat  // 启动开始执行ff.bat（启动ff.bat脚本后，原脚本继续执行，不会等ff.bat脚本执行完）</p><p><strong>exit</strong>  退出当前cmd窗口实例</p><p>例：exit 0  // 退出当前cmd窗口实例，并将过程退出代码设置为0（0表示成功，非0表示失败）</p><p>例：exit /B 1  // 退出当前bat脚本，并将ERRORLEVEL系统变量设置为1</p><p><strong>pause</strong>   暂停批处理程序，并显示出：请按任意键继续….</p><p><strong>color</strong>  设置当前cmd窗口背景色和前景色（前景色即为字体的颜色）</p><p>例：color  // 恢复到缺省设置</p><p>例：color 02 // 将背景色设为黑色，将字体设为绿色</p><p>-————————————-<br>    0 = 黑色       8 = 灰色<br>    1 = 蓝色       9 = 淡蓝色<br>    2 = 绿色       A = 淡绿色<br>    3 = 浅绿色     B = 淡浅绿色<br>    4 = 红色       C = 淡红色<br>    5 = 紫色       D = 淡紫色<br>    6 = 黄色       E = 淡黄色<br>    7 = 白色       F = 亮白色<br>-————————————-</p><p><strong>mode con cols=200 lines=60 &amp; color 9f</strong>    设置DOS窗口颜色为9f，大小：200行 60列（若屏幕缓冲区大小的宽度w&lt;200或高度h&lt;60,最终DOS的窗口就会为w行，h列）</p><p><img src="https://images0.cnblogs.com/blog/78946/201408/261651364389696.jpg" alt="img"></p><p><strong>chcp</strong>  查看命令行环境字符编码（为一个全局设置）</p><p>936 – GBK(一般情况下为默认编码)<br>437 – 美国英语<br>65001 – utf-8<br>1200 – utf-16<br>1201 – utf-16(Big-Endian)<br>12000 – utf-32<br>12001 – utf-32(Big-Endian)</p><p>注：cmd的属性窗口，选项标签页也可以查看当前代码页</p><p><img src="https://images2018.cnblogs.com/blog/78946/201807/78946-20180719203311480-63725241.png" alt="img"></p><p><strong>chcp  936</strong>  // 设置当前命令行环境编码为GBK  执行完该命令后还需要将字体设置为点阵字体，才能真正将编码环境切成utf8</p><p><img src="https://images2018.cnblogs.com/blog/78946/201807/78946-20180720111938013-1747757769.png" alt="img"></p><p><strong>chcp  65001</strong>  // 设置当前命令行环境编码为utf8  执行完该命令后还需要将字体设置为Lucida Console，才能真正将编码环境切成utf8</p><p><img src="https://images2018.cnblogs.com/blog/78946/201807/78946-20180720111604172-832860971.png" alt="img"></p><p>在注册表中会写入这些字段信息：</p><p><img src="https://images2018.cnblogs.com/blog/78946/201807/78946-20180720111812485-1565188150.png" alt="img"></p><p><strong>systeminfo</strong>  查看当前计算机的综合信息</p><p><strong>systeminfo | findstr /i “初始安装日期 系统启动时间”</strong>   只查看当前计算机的初始安装日期和系统启动时间</p><p><strong>wmic</strong> 查看硬件的信息   – C:\Windows\System32\wbem\WMIC.exe</p><p>例：wmic logicaldisk   // 查看计算机上各个盘的相关信息</p><p>例：wmic LogicalDisk where “Caption=’C:’” get FreeSpace,Size /value   // 获取C盘的剩余空间大小与总大小（单位：Byte）</p><p>例：wmic os get Caption,InstallDate,OSArchitecture /value  // 获取当前os的Caption、安装日期以及系统架构信息</p><p><strong>wmic</strong> 查看进程信息</p><p>例：wmic process where Caption=”buyticket.exe” get commandline,ExecutablePath,ProcessId,ThreadCount /value // 查看名为”buyticket.exe”所有进程命令行，exe全路径，PID及线程数</p><p>例：wmic process where Caption=”buyticket.exe” get ExecutablePath,HandleCount /value   // 查看名为”buyticket.exe”所有进程的exe全路径及当前打开的句柄数</p><p>例：wmic process where Caption=”buyticket.exe” get ExecutablePath,VirtualSize,WorkingSetSize /value   // 查看名为”buyticket.exe”所有进程的exe全路径、当前虚拟地址空间占用及物理内存工作集</p><p><strong>logoff</strong>  注销当前用户</p><p><strong>shutdown</strong>  关闭、重启、注销、休眠计算机</p><p>例：shutdown /s  // 关闭计算机</p><p>例：shutdown /s /t 3600  // 一小时后，关闭本地计算机</p><p>例：shutdown /a  // 终止系统关闭</p><p>例：shutdown /r  // 关闭并重启本地计算机</p><p>例：shutdown /m 192.168.1.166 /r  // 关闭并重启ip为192.168.1.166的计算机</p><p>+++++++++++++++++++++</p><p>远程关机权限的获取：<br>1）修改远程pc的“本地安全策略”，为指定的用户开放权限<br>在WindowsXP默认的安全策略中，只有Administrators组的用户才有权从远端关闭计算机，如果要给xxxx用户远程关机的权限。<br>可利用WindowsXP的“组策略”或“管理工具”中的“本地安全策略”来实现。<br>1.命令行运行gpedit.msc打开“组策略编辑器“；<br>2.导航到“计算机配置/Windows设置/安全设置/本地策略/用户权利指派”；<br>3.修改“从远端系统强制关机”，添加xxxx用户即可。</p><p>2）获得远程IPC管理权限<br>如果配置第一步后还出现“拒绝访问。”，则需要在运行shutdown命令前先运行如下命令<br>net use \[ip地址或计算机名]\ipc$ password /user:xxxx<br>其中password为帐号xxxx的登录密码。</p><p>+++++++++++++++++++++</p><p>例：shutdown /g  // 关闭并重启计算机，重启后重新启动所有注册的应用程序</p><p>例：shutdown /l  // 注销本地计算机</p><p>例：shutdown /h /f // 休眠本地计算机（强制正在运行的应用程序关闭，不前台警告用户）</p><p>例：shutdown /s  // 关闭计算机</p><p><strong>regsvr32</strong>  注册或反注册com组件</p><p>例：regsvr32 /s clock.ocx  // 以无声的方式注册clock.ocx组件</p><p>例：regsvr32 /u myCommon.dll  // 卸载myCommon.dll组件</p><p><strong>format</strong>  格式化磁盘</p><p>例：format J: /FS:ntfs   // 以ntfs类型格式化J盘 【类型有:FAT、FAT32、exFAT、NTFS或UDF】</p><p>例：format J: /FS:fat32 /Q  //  以fat32类型快速格式化J盘</p><p><strong>chkdsk /f D:</strong>   // 检查磁盘D并显示状态报告；加参数/f表示同时会修复磁盘上的错误</p><p><strong>subst</strong>   磁盘映射  – 磁盘映射信息都保存在注册表以下键值中：HKEY_CURRENT_USER\Network</p><p>例：subst  // 显示目前所有的映射</p><p>例：subst z: \com\software  // 将\com\software共享映射为本地z盘</p><p>例：subst y: e:\src  // 将e:\src映射为本地y盘</p><p>例：subst z: /d  // 删除z盘映射</p><p><strong>cmdkey</strong>   凭据（保存的用户名和密码）</p><p>例：cmdkey /list  // 列出可用的凭据</p><p>例：cmdkey /list:10.12.190.82  // 列出指定目标的凭据</p><p>例：cmdkey /list:Domain:target=10.12.190.82  // 列出指定目标的凭据</p><p>例：cmdkey /add:Domain:target=10.12.190.82 /user:LiLei /pass:123456  // 若target为10.12.190.82的凭据不存在，则添加；否则就将10.12.190.82凭据的用户名修改为LiLei，密码修改为123456</p><p>例：cmdkey /delete:Domain:target=10.12.190.82  // 删除指定目标的凭据</p><p><strong>cscript</strong>  执行vbs脚本</p><p>例：cscript /Nologo mac.vbs  // 执行mac.vbs脚本，显示本机mac地址</p><p>——-mac.vbs———-</p><p>Dim mc,mo<br>Set mc=GetObject(“Winmgmts:”).InstancesOf(“Win32_NetworkAdapterConfiguration”)<br>For Each mo In mc<br>If mo.IPEnabled=True Then<br>MsgBox “本机网卡MAC地址是: “ &amp; mo.MacAddress<br>Exit For<br>End If<br>Next</p><p>-————————-</p><p><strong>schtasks</strong>  任务计划</p><p>例：schtasks /query /fo LIST /v  // 以较为详细易于阅读的格式显示本机所有任务计划信息</p><p>例：schtasks /create /sc minute /mo 20 /tn “Soda Build” /tr d:\check.vbs  // 创建一个名为Soda Build的任务计划：该任务计划每20分钟执行一下d:\check.vbs脚本</p><p>例：schtasks /create /tn “Soda Build” /tr D:\updateall.bat /sc daily /st 02:06 /f  // 强制创建一个名为Soda Build的任务计划（不进行确认）：该任务计划每天凌晨2点06分执行一下D:\updateall.bat脚本</p><p>例：schtasks /delete /tn “Soda Build” /f  // 强制删除Soda Build名称的任务计划（不进行确认）</p><p>例：schtasks /change /tn “Soda Build” /tr d:\check2.vbs  // 将名为Soda Build的任务计划的执行脚本修改为d:\check2.vbs</p><p>例：schtasks /run /tn “Soda Build” // 执行名为Soda Build的任务计划</p><p>例：schtasks /end /tn “Soda Build” // 终止执行名为Soda Build的任务计划</p><h2 id="6-net命令"><a href="#6-net命令" class="headerlink" title="6. net命令"></a><strong>6. net命令</strong></h2><p><strong>net start</strong>  // 查看已经启动的服务</p><p><strong>net start “Task Scheduler”</strong>   // 开启任务计划服务</p><p><strong>net stop “Task Scheduler”</strong>   // 关闭任务计划服务</p><p><strong>net start dnscache</strong>  // 开启dns缓存服务</p><p><strong>net stop dnscache</strong>  // 关闭dns缓存服务</p><p><strong>net share</strong>   // 查看当前用户下的共享目录</p><p><strong>net share workFile /delete</strong>  // 取消名为workFile的共享状态</p><p><strong>net share xxx=c:\360Downloads</strong>   // 将c:\360Downloads设为共享，并取名为xxx</p><p><strong>net share ipc$</strong> // 开启ipc$共享</p><p><strong>net share ipc$ /del</strong>   // 删除ipc$共享</p><p><strong>net share c$ /del</strong> // 删除c盘共享</p><p><strong>net use \192.168.1.166\ipc$ “ “ /user:” “</strong> // 建立192.168.1.166的ipc空链接</p><p><strong>net use \192.168.1.166\ipc$ “123456” /user:”administrator”</strong>   // 直接登陆后建立192.168.1.166的ipc非空链接（用户名为administrator 密码为123456）</p><p><strong>net use h: \192.168.1.166\c$ “123456” /user:”administrator”</strong>   // 直接登陆后映射192.168.1.166的c盘到本地为h盘（用户名为administrator 密码为123456）</p><p><strong>net use h: \192.168.1.166\c$</strong>   // 登陆后映射192.168.1.166的c盘到本地为h盘</p><p><strong>net use \192.168.1.166\ipc$ /del</strong>  // 删除ipc链接</p><p><strong>net use h: /del</strong>  // 删除本地的h盘的映射 </p><p><strong>net view</strong>   // 查看本地局域网内开启了哪些共享</p><p><strong>net view \192.168.1.166</strong>  // 查看192.168.1.166的机器上在局域网内开启了哪些共享</p><p><strong>net time \127.0.0.1</strong>   // 查看本地机器的日期及时间</p><p><strong>net time \localhost</strong>   // 查看本地机器的日期及时间</p><p><strong>net time \192.168.1.166</strong>   // 查看192.168.1.166机器的日期及时间</p><p><strong>net time \192.168.1.166 /set</strong>  // 设置本地计算机时间与192.168.1.166主机的时间同步，加上参数/yes可取消确认信息</p><p><strong>net user</strong>  // 查看当前机器上的用户</p><p><strong>net user Administrator</strong>   // 查看当前机器上的Administrator用户的信息</p><p><strong>net user Guest /active:yes</strong>  // 启用Guest用户</p><p><strong>net user dev 123456 /add</strong>   // 新建一个名为dev，密码为123456的用户</p><p><strong>net localgroup administrators dev /add</strong>  // 把名为dev的用户添加到管理员用户组中，使其具有管理员权限</p><p><strong>net user dev /del</strong>  // 删除名为dev的用户</p><h2 id="7-进程操作"><a href="#7-进程操作" class="headerlink" title="7. 进程操作"></a><strong>7. 进程操作</strong></h2><p><strong>tasklist</strong>  // 显示当前运行的进程信息（可查看PID）</p><p><strong>taskkill</strong>  结束指定的进程</p><p>例：taskkill /im notepad.exe  // 结束名为notepad.exe的进程</p><p>例：taskkill /pid 1230 /pid 1241 /pid 1253 /t // 结束pid为1230、1241和1253的进程以及由它们启动起来的子进程</p><p>例：taskkill /f /im cmd.exe /t   // 强制结束有名为cmd.exe的进程以及由它启动起来的子进程</p><h2 id="8-网络操作"><a href="#8-网络操作" class="headerlink" title="8. 网络操作"></a><strong>8. 网络操作</strong></h2><p><strong>ping</strong>  // 用于检测网络是否通畅，以及网络时延情况（工作在ICMP协议上）</p><p>例：ping baidu.com   //  测试与baidu服务器的连接情况</p><p>例：ping chen-pc0   // 测试机器名为chen-pc0的连接情况</p><p>例：ping 220.181.111.86   // 测试与ip为220.181.111.86的连接情况</p><p>例：ping -l 65500 -n 10 qq.com   // 向qq.com发送10次65500字节的ping</p><p>例：ping -n 6 127.0.0.1 // 对当前主机执行6次ping操作（花费时间为5s）</p><p>例：ping -t baidu.com   // 不断地测试baidu服务器的连接情况   【Ctrl+Pause Break：查看ping的统计信息；Ctrl+C：终止当前任务】</p><p>a. 首先查本地arp cache信息，看是否有对方的mac地址和IP地址映射条目记录<br>b. 如果没有，则发起一个arp请求广播包，等待对方告知具体的mac地址<br>c. 收到arp响应包之后，获得某个IP对应的具体mac地址，有了物理地址之后才可以开始通信了,同时对ip-mac地址做一个本地cache<br>d. 发出icmp echo request包，收到icmp  echo reply包</p><p><strong>ipconfig /all</strong>  // 查看本地ip地址等详细信息</p><p><strong>ipconfig /displaydns</strong>  // 显示本地dns缓存的内容</p><p><strong>ipconfig /flushdns</strong>  // 清除本地dns缓存的内容</p><p><strong>nslookup <a href="http://www.cnblogs.com" target="_blank" rel="noopener">www.cnblogs.com</a></strong>  // 获取<a href="http://www.cnblogs.com的域名解析" target="_blank" rel="noopener">www.cnblogs.com的域名解析</a></p><p>服务器: gm-captiva.tencent.com//DNS服务器的主机名<br>Address:  10.6.18.41//DNS服务器IP</p><p>非权威应答:<br>名称:    <a href="http://www.cnblogs.com//解析的域名URL" target="_blank" rel="noopener">www.cnblogs.com//解析的域名URL</a><br>Address:  42.121.252.58//解析回的IP</p><p><strong>nslookup -d <a href="http://www.cnblogs.com" target="_blank" rel="noopener">www.cnblogs.com</a></strong>  // 打印出<a href="http://www.cnblogs.com的域名解析所有记录" target="_blank" rel="noopener">www.cnblogs.com的域名解析所有记录</a></p><p><strong>netstat -a</strong>   // 查看开启了哪些端口</p><p><strong>netstat -n</strong>  // 查看端口的网络连接情况</p><p><strong>netstat -v</strong>   // 查看正在进行的工作</p><p><strong>netstat -p tcp</strong>  // 查看tcp协议的使用情况</p><p><strong>tracert 182.140.167.44</strong>  // 查看本机到达182.140.167.44的路由路径</p><p><strong>route print</strong>  // 显示出IP路由</p><p><strong>telnet 182.140.167.44 8000</strong>   // 探测182.140.167.44是否使用TCP协议监听8000端口（注意：telnet命令不支持UDP端口检测）</p><p>说明：如果端口关闭或者无法连接，则显示不能打开到主机的链接，链接失败；端口打开的情况下，链接成功，则进入telnet页面（全黑的），证明端口可用。</p><p>用于探测指定IP的端口号，只是telnet的一个基本功能；</p><p>远程登录到网络中的计算机，并以命令行的方式远程管理计算机才是telnet命令的强大之处。</p><p><strong>windows telnet服务器(默认端口：23)环境配置过程如下</strong>： <a href="http://winsystem.ctocio.com.cn/Longhorn/472/8756972.shtml" target="_blank" rel="noopener">参考1</a></p><p>a. 安装telnet服务器</p><p><img src="https://images2015.cnblogs.com/blog/78946/201609/78946-20160902142422215-1607922084.png" alt="img"></p><p>b. 启动Telnet服务</p><p><img src="https://images2015.cnblogs.com/blog/78946/201609/78946-20160902144707308-2120239427.png" alt="img"></p><p>c. 关闭windows防火墙    注：若不想关闭防火墙，则需要在Windows防火墙 – 高级设置里面对Telnet服务器的访问规则进行配置</p><p><img src="https://images2015.cnblogs.com/blog/78946/201609/78946-20160902150418730-745820459.png" alt="img">  <img src="https://images2015.cnblogs.com/blog/78946/201609/78946-20160902150424652-1363165395.png" alt="img"></p><p><strong>ftp 46.19.34.198 21</strong>  // 连接46.19.34.198 ftp服务器（21为端口号），然后会要求输入用户名与密码；连接成功后，具体如何使用可以键入?来查看帮助说明</p><p><strong>arp</strong>   显示和修改地址解析协议(ARP)使用的“IP到mac”的地址转换表</p><p>例：arp -a  // 显示arp缓存表</p><p><strong>at</strong>  计划任务（必须保证“Task Scheduler”服务启动   net start “task scheduler”）</p><p>例：at  // 查看所有的计划任务</p><p>例：at /delete /yes  // 停止所有任务计划（不需要确认）</p><p>例：at 1  // 开启id为1的计划任务</p><p>例：at 1 /delete /yes  // 停止id为1的计划任务（不需要确认）</p><p>例：at 12:42 shutdown –s –t30   // 到12:42 ，电脑会出现“ 系统关机 ”对话框，并默认 30 秒延时自动关机</p><p>例：at cmd /c dir &gt; c:\test.out   // 如果命令不是exe文件，必须在命令前加上cmd /c</p><p>例：at 6:00AM /every:Saturday task.bat   // 在每周六早上6点，电脑定时启动task.bat批处理文件</p><p>例：at \chen 12:00 shutdown /r   // 到12:00时，关闭名为chen的计算机</p><p>例：at \192.168.1.166 12:00 shutdown /r   // 到12:00时，关闭ip为192.168.1.166的计算机</p><h2 id="9-文本处理"><a href="#9-文本处理" class="headerlink" title="9. 文本处理"></a><strong>9. 文本处理</strong></h2><p><strong>edit config.ini</strong>  // 编辑config.ini文件（会进入edit字符编辑器；按alt，可以选择对应的菜单） win7 x64下没有该命令</p><p><strong>find</strong>  文件中搜索字符串</p><p>例：find /N /I “pid” 1.txt  // 在1.txt文件中忽略大小写查找pid字符串，并带行号显示查找后的结果</p><p>例：find /C “exe” 1.txt  // 只显示在1.txt文件中查找到exe字符串的次数</p><p>例：find /V “exe” 1.txt  // 显示未包含1.txt文件中未包含exe字符串的行</p><p><strong>findstr</strong>  文件中搜索字符串</p><p>例：findstr “hello world” 1.txt  // 在1.txt文件中搜索hello或world</p><p>例：findstr /c:”hello world” 1.txt  // 在1.txt文件中搜索hello world</p><p>例：findstr /c:”hello world” 1.txt nul  // 在1.txt文件中搜索hello world，并在每行结果前打印出1.txt:   注：findstr只有在2个及以上文件中搜索字符串时才会打印出每个文件的文件名，nul表示一个空文件</p><p>例：findstr /s /i “Hello” <em>.</em>   // 不区分大小写，在当前目录和所有子目录中的所有文件中的hello</p><p>例：findstr  “^[0-9][a-z]” 1.txt  // 在1.txt中搜索以1个数字+1个小写字母开头子串的行</p><blockquote><p>本文转载自博客园：</p><p>博主：可可西</p><p>原文链接：<a href="http://www.cnblogs.com/kekec/p/3662125.html" target="_blank" rel="noopener">http://www.cnblogs.com/kekec/p/3662125.html</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《爱的艺术》思维导图</title>
      <link href="/post/1822a02.html"/>
      <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>　　<strong>爱不是一种只需投入身心就可获得的感情</strong>，如果不努力发展自己的全部人格并以此达到一种创造倾向性，那么每种爱的试图都会失败；如果没有爱他人的能力，如果不能真正勇敢地、真诚地、有纪律地爱他人，那么人们在自己的爱情生活中也永远得不到满足。不信，每个人都可以问问自己，你确实见过多少真正有能力爱的人呢？<br><a id="more"></a></p><h1 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h1><p>　　我当初打算看这本书的原因可以说就是被这本书的书名吸引了————“爱的艺术”。为什么爱可以被称为一种艺术？爱不是一种人与生俱来的天性吗？当爱成为一种艺术，那会是什么样？<br>    当我看完这本书，我最大的感受就是————<strong>爱，是一门一生的艺术。</strong><br>只有先明白爱的艺术，才能真正拥抱爱。</p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><a href="https://pan.baidu.com/s/1WE4qv54ZbuLPV_QVy6uADA" target="_blank" rel="noopener">百度网盘点击下载</a>密码：ibuz</p><h1 id="本书简介"><a href="#本书简介" class="headerlink" title="本书简介"></a>本书简介</h1><img src="/post/1822a02/fengpi.jpg" title="封面"><blockquote><p>　　这本书必定会使所有期望从这本书得到掌握爱的艺术秘诀的读者大失所望。恰恰相反，这本书要告诉读者，<br><strong>爱情不是一种与人的成熟程度无关 ，只需要投入身心的感情。</strong><br>这本书要说服读者：如果不努力发展自己的全部人格并以此达到一种创造倾向性，那么每种爱的试图都会失败；如果没有爱他人的能力，如果不能真正谦恭地、勇敢地、真诚地和有纪律地爱他人，那么人们在自己的爱情生活中也永远得不到满足。每个人都可以问问自己，你确实见过多少真正有能力爱的人呢？</p></blockquote><h1 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h1><p>Fromm，Erich（1900～1980）<br>德国精神病学家，新精神分析学家,是精神分析学派的代表人物之一。1922年获海德堡大学哲学博士学位。次年入慕尼黑大学研究精神分析，并在柏林精神分析学院接受训练。1929年在法兰克福精神分析学院和法兰克福大学任教。1934年移居美国。先后任教于哥伦比亚大学、耶鲁大学、密歇根州立大学。弗罗姆十分重视人与社会的关系的研究。他承认人的生物性，但更强调人的社会性，认为人的本质是由文化的或社会的因素而不是生物的因素决定的。人在现代社会中普遍具有孤独感，这是人在社会中达到个性化的必然结果。为了医治病态社会，他提出通过改善人的心理，解决有关人们的劳动组织与社会的相互关系的问题，建立一个友爱、互助、没有孤独感的理想社会。著有《逃避自由》、《精神分析与宗教》、《论健全的社会》、《人类破坏性的分析》等。</p><p>艾·弗罗姆把心理学视为是人性之自我理解这一久远努力的延续。当运用人类学与社会学的洞见以拓展来自临床、心理分析和精神病学研究的知识之时，弗罗姆充分地汲取思想史的养料，并提醒他的读者：以往的伦理思索者乃是哲学家以及心理学家。弗罗姆在基本观点上是一个弗洛伊德主义者，且显示出弗洛伊德见解的广度与深度。他同时强调了弗洛伊德思想的开放性实质，因而避免了教条主义，并且能面对他最初的思想源泉仍然保持极有意义的游刃有余。 尽管弗罗姆著有许多著作，但《逃避自由》是他最著名的一本。在此书中他论证，正如不能离开对文化内容的解释去理解个人一样，要理解社会过程同样不能不懂得作用于个人的心理过程。“前个人主义社会”给个人以安全，但严重地限制了个人的自由发展。自中世纪的封建秩序解体之后，人已摆脱了传统的束缚，但他并没有在他个人自我实现的积极意义上获得自由。个人主义的历史发展已提供幸福的许多可能，但今天的个人必须有内在勇气去激发他全部的潜能，否则他就会寻求在限制自我的新的依赖形式中逃避他的自由。外界限制的根除不足以使人有积极的自由：“来”（from）自于什么的自由可能是个前提，但“去”（to）创造争取的自由对于人的成长是基本的。法西斯政权的兴起以援引在民主手段、经济秩序或政治欺诈中的经验不足来解释是不能令人满意的，它置根于普及于人民大众的许多内在观点之中。</p><p>弗洛姆创立以关于人的处境的学说为基础的人本主义精神分析，注重分析一定的经济结构对人的影响，提出社会性格及社会潜意识论，认为这些是联系经济基础与意识形态的中介环节，并强调社会心理在社会进程中的作用。他试图据此解释现代西方人的困境及精神危机，就此提出社会改革论。</p><h1 id="书籍下载"><a href="#书籍下载" class="headerlink" title="书籍下载"></a>书籍下载</h1><p><a href="https://pan.baidu.com/s/1AGHjTKu_kqkWdMuaPkMe_g" target="_blank" rel="noopener">百度网盘点击下载</a>密码：562r</p>]]></content>
      
      <categories>
          
          <category> 思维导图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World!</title>
      <link href="/post/1c291ca3.html"/>
      <content type="html"><![CDATA[<p>这里是crazyjackong的个人博客，开启于2018年3月17日。<br>欢迎各位客官！！</p>]]></content>
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
